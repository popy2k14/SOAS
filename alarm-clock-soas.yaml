i2c:
  sda: ${i2c_sda}
  scl: ${i2c_scl}
  frequency: 800kHz

i2s_audio:
  - id: i2s_out
    i2s_lrclk_pin: ${i2s_lrclk_pin}
    i2s_bclk_pin: ${i2s_bclk_pin}

media_player:
  - platform: i2s_audio
    name: Media player alarm
    id: media_player_alarm
    dac_type: external
    i2s_dout_pin: ${i2s_dout_pin}
    mode: mono
    on_play:
      - lambda: |-
          id(last_play_started) = id(ntp).now().timestamp;
          ESP_LOGI("media", "Playback started!");
    on_pause:
      - logger.log: "Playback paused!"
    on_idle:
      - lambda: |-
          int now = id(ntp).now().timestamp;
          int diff = now - id(last_play_started);
          ESP_LOGI("media", "Playback finished! (diff=%d sec)", diff);
          if ((diff < 4) && (id(alarm_on).state)) {
            ESP_LOGW("media", "Alarm is ON and stream failed, playing RTTTL fallback!");
            id(alarm_on_local).turn_on();            
          }

output:
  - platform: ledc
    pin: $buzzer_pin
    id: rtttl_out
    
rtttl:
  id: my_rtttl
  output: rtttl_out
  gain: $buzzer_gain
  on_finished_playback:
    - logger.log: 'Song ended!'  
  
api:
  services:
    - service: tune
      variables:
        tune: string
      then:
        - rtttl.play:
            rtttl: !lambda 'return tune;'

font:
  - file: fonts/Roboto-Medium.ttf
    id: robotomedium40
    size: 40
    <<: &extras
      extras:
        - file: "fonts/materialdesignicons-webfont.ttf"
          glyphs: [ #https://github.com/juliettef/IconFontCppHeaders/blob/main/IconsMaterialDesignIcons.cs
            "\U000F091F", # WifiStrength1
            "\U000F0922", # WifiStrength2
            "\U000F0925", # WifiStrength3
            "\U000F0928", # WifiStrength4
            "\U000F092F", # WifiStrengthOutline
            "\U000F092E", # WifiStrengthOffOutline
            "\U000F0020", # Alarm
            "\U000F0E71", # AlarmNote
            "\U000F0023", # AlarmOff
            "\U000F0021", # AlarmCheck
            "\U000F068E", # AlarmSnooze;
            "\U000F1ADD", # TimerMusicOutline
            "\U000F07D0", # HomeAssistant
            "\U000F15D0", # HomeAlertOutline
            "\U000F1A47", # HomeOffOutline
            "\U000F0197", # ContrastCircle
            "\U000F0157", # CloseBox
            "\U000F0158", # CloseBoxOutline
            "\U000F0C52", # CheckboxOutline
            "\U000F0132", # CheckboxMarked
            "\U000F0131", # CheckboxBlankOutline
            "\U000F09DF", # CircleSmall
            "\U000F0764", # Square
            "\U000F0A13", # SquareMedium
            "\U000F0763", # SquareOutline
            "\U000F057E", # VolumeHigh
          ]
  - file: fonts/Roboto-Medium.ttf
    id: robotomedium51
    size: 51
    <<: *extras
  - file: fonts/Roboto-Medium.ttf
    id: robotomedium30
    size: 30
    <<: *extras
  - file: fonts/Roboto-Medium.ttf
    id: robotomedium20
    size: 20
    <<: *extras
  - file: fonts/Roboto-Medium.ttf
    id: robotomedium15
    size: 15
    <<: *extras
  - file: fonts/roboto-thin.ttf
    id: robotothin51
    size: 51
    <<: *extras
  - file: fonts/roboto-thin.ttf
    id: robotothin20
    size: 20
    <<: *extras
  - file: fonts/roboto-thin.ttf
    id: robotothin15
    size: 15
    <<: *extras

globals:
  - id: time_sync_done
    type: bool
    initial_value: "false"
  - id: time_sunrise
    type: bool
  - id: current_page_id
    type: int
    initial_value: "1"
  - id: rotate_switch_single
    type: int
    initial_value: "0"
  - id: rotate_switch_double
    type: int
    initial_value: "0"
  - id: api_connected
    type: bool
    restore_value: no
    initial_value: 'false'
  - id: alarm_last_off
    type: int
    restore_value: yes
    initial_value: '0'
  - id: snooze_timestamp
    type: int
    restore_value: yes
    initial_value: '0'
  - id: last_play_started
    type: int
    restore_value: no
    initial_value: "0"
    

interval:
  - interval: 10s
    then:
      #api connection state
      - if:
          condition:
            api.connected:
          then:
            - if:
                condition:
                  - lambda: 'return { (id(api_connected) != true) };'
                then:
                  - lambda: |-
                      ESP_LOGD("interval", "Api connected. Setting api_connected to true");
                      id(api_connected) = true;
          else:
             - if:
                condition:
                  not:
                    api.connected:
                then:
                  - if:
                      condition:
                        - lambda: 'return { (id(api_connected) == true) };'
                      then:
                        - lambda: |-
                            ESP_LOGD("interval", "Api disconnected. Setting api_connected to false");
                            id(api_connected) = false;

time:
  - platform: sntp
    id: ntp
    on_time_sync:
      then:
        lambda: |-
          id(time_sync_done) = true;
    on_time:
      - seconds: 0,30
        minutes: "*"
        then:
          - script.execute: check_alarms
          - if:
              condition:
                - sun.is_above_horizon:
              then:
                - globals.set:
                    id: time_sunrise
                    value: "true"
              else:
                - globals.set:
                    id: time_sunrise
                    value: "false"

sun:
  latitude: ${sun_latitude}
  longitude: ${sun_longitude}

number:
  - platform: template
    name: Screen contrast day
    optimistic: true
    id: screen_contrast_day
    initial_value: 0
    restore_value: true
    min_value: 0
    max_value: 100
    step: 1
    mode: slider
  - platform: template
    name: Screen contrast night
    optimistic: true
    id: screen_contrast_night
    initial_value: 0
    restore_value: true
    min_value: 0
    max_value: 100
    step: 1
    mode: slider
  - platform: template
    id: alarm_hour
    name: "Alarm hour"
    entity_category: config
    optimistic: true
    restore_value: true
    initial_value: 0
    min_value: 0
    max_value: 23
    step: 1
    mode: slider
    on_value:
      - script.execute:
          id: set_ha_0_trigger_time_script
      - script.execute:
          id: set_alarm_last_off
  - platform: template
    name: "Alarm minute"
    id: alarm_minute
    entity_category: config
    optimistic: true
    restore_value: true
    initial_value: 0
    min_value: 0
    max_value: 59
    step: 1
    mode: slider
    on_value:
      - script.execute:
          id: set_ha_0_trigger_time_script
      - script.execute:
          id: set_alarm_last_off
  - platform: template
    name: "Snooze duration"
    id: snooze_duration
    entity_category: config
    optimistic: true
    restore_value: true
    initial_value: 9
    min_value: 1
    max_value: 99
    step: 1
    mode: slider
  - platform: template
    name: "Home Assistant 1 pre minute"
    id: ha_1_pre_minute
    entity_category: config
    optimistic: true
    restore_value: true
    initial_value: 0
    min_value: -99
    max_value: 99
    step: 1
    mode: slider
    on_value:
      - script.execute:
          id: set_ha_1_trigger_time_script
  - platform: template
    name: "Home Assistant 1 minute"
    id: ha_1_minute
    entity_category: config
    optimistic: true
    restore_value: true
    initial_value: 0
    min_value: 0
    max_value: 59
    step: 1
    internal: true
  - platform: template
    name: "Home Assistant 1 hour"
    id: ha_1_hour
    entity_category: config
    optimistic: true
    restore_value: true
    initial_value: 0
    min_value: 0
    max_value: 23
    step: 1
    internal: true
  - platform: template
    name: "Home Assistant 2 pre minute"
    id: ha_2_pre_minute
    entity_category: config
    optimistic: true
    restore_value: true
    initial_value: 0
    min_value: -99
    max_value: 99
    step: 1
    mode: slider
    on_value:
      - script.execute:
          id: set_ha_2_trigger_time_script
  - platform: template
    name: "Home Assistant 2 minute"
    id: ha_2_minute
    entity_category: config
    optimistic: true
    restore_value: true
    initial_value: 0
    min_value: 0
    max_value: 59
    step: 1
    internal: true
  - platform: template
    name: "Home Assistant 2 hour"
    id: ha_2_hour
    entity_category: config
    optimistic: true
    restore_value: true
    initial_value: 0
    min_value: 0
    max_value: 23
    step: 1
    internal: true
  - platform: template
    name: "Home Assistant 3 pre minute"
    id: ha_3_pre_minute
    entity_category: config
    optimistic: true
    restore_value: true
    initial_value: 0
    min_value: -99
    max_value: 99
    step: 1
    mode: slider
    on_value:
      - script.execute:
          id: set_ha_3_trigger_time_script
  - platform: template
    name: "Home Assistant 3 minute"
    id: ha_3_minute
    entity_category: config
    optimistic: true
    restore_value: true
    initial_value: 0
    min_value: 0
    max_value: 59
    step: 1
    internal: true
  - platform: template
    name: "Home Assistant 3 hour"
    id: ha_3_hour
    entity_category: config
    optimistic: true
    restore_value: true
    initial_value: 0
    min_value: 0
    max_value: 23
    step: 1
    internal: true
  - platform: template
    name: "Home Assistant 4 pre minute"
    id: ha_4_pre_minute
    entity_category: config
    optimistic: true
    restore_value: true
    initial_value: 0
    min_value: -99
    max_value: 99
    step: 1
    mode: slider
    on_value:
      - script.execute:
          id: set_ha_4_trigger_time_script
  - platform: template
    name: "Home Assistant 4 minute"
    id: ha_4_minute
    entity_category: config
    optimistic: true
    restore_value: true
    initial_value: 0
    min_value: 0
    max_value: 59
    step: 1
    internal: true
  - platform: template
    name: "Home Assistant 4 hour"
    id: ha_4_hour
    entity_category: config
    optimistic: true
    restore_value: true
    initial_value: 0
    min_value: 0
    max_value: 23
    step: 1
    internal: true
  - platform: template
    name: "Alarm volume"
    id: alarm_volume
    entity_category: config
    optimistic: true
    restore_value: true
    initial_value: 0
    min_value: 0
    max_value: 100
    step: 1
    mode: slider
    on_value:
      - media_player.volume_set: !lambda "return (x/100);"
  - platform: template
    name: "Sleep timer duration"
    id: sleep_timer_duration
    entity_category: config
    optimistic: true
    restore_value: true
    initial_value: 10
    min_value: 10
    max_value: 180
    step: 5
    mode: slider
  - platform: template
    name: "Sleep timer timestamp"
    id: sleep_timer_timestamp
    entity_category: config
    optimistic: true
    restore_value: true
    initial_value: 0
    min_value: 0
    max_value: 9223372036854775807
    on_value:
      then:
        - if:
            condition:
              lambda: 'return (id(time_sync_done) == true);'
            then:
              - lambda:
                  time_t sleepTimerTimestampX = x;
                  char sleepTimer[6];
                  strftime(sleepTimer, sizeof(sleepTimer), "%H:%M", localtime(&sleepTimerTimestampX));
                  id(sleep_timer_time).publish_state(sleepTimer);
    step: 1
    internal: true

text_sensor:
  - platform: template
    name: "Sleep timer time"
    id: sleep_timer_time
    lambda: |-
      time_t sleepTimerTimestampTS = id(sleep_timer_timestamp).state;
      char sleepTSDisplay[6];
      strftime(sleepTSDisplay, sizeof(sleepTSDisplay), "%H:%M", localtime(&sleepTimerTimestampTS));
      return esphome::str_sprintf(sleepTSDisplay);
    update_interval: 60s
  - platform: template
    name: "Snooze time"
    id: snooze_time
    lambda: |-
      time_t snoozeTimestampTS = id(snooze_timestamp);
      char snoozeTSDisplay[6];
      strftime(snoozeTSDisplay, sizeof(snoozeTSDisplay), "%H:%M", localtime(&snoozeTimestampTS));
      return esphome::str_sprintf(snoozeTSDisplay);
    update_interval: 60s
  - platform: template
    name: "Home Assistant 1 time"
    id: ha_1_time
  - platform: template
    name: "Home Assistant 2 time"
    id: ha_2_time
  - platform: template
    name: "Home Assistant 3 time"
    id: ha_3_time
  - platform: template
    name: "Home Assistant 4 time"
    id: ha_4_time

sensor:
  - platform: wifi_signal
    name: "WiFi Signal Sensor"
    id: wifi_signal_db
    update_interval: 60s
  - platform: copy # Reports the WiFi signal strength in %
    source_id: wifi_signal_db
    id: wifi_signal_percent
    name: "WiFi Signal Percent"
    filters:
      - lambda: return min(max(2 * (x + 100.0), 0.0), 100.0);
    unit_of_measurement: "Signal %"
    entity_category: "diagnostic"
    device_class: ""
  - platform: rotary_encoder
    name: "Rotary Encoder"
    pin_a:
      number: ${pin_a}
      mode: INPUT_PULLUP
    pin_b:
      number: ${pin_b}
      mode: INPUT_PULLUP
    on_anticlockwise:
      then:
        - if:
            condition:
              and:
                - switch.is_on: enable_display_on_interaction
                - switch.is_off: display_enabled
            then:
              - switch.turn_on: display_enabled
            else:
              - if:
                  condition:
                    lambda: |-
                      if (id(current_page_id) == 1 && id(alarm_on).state) {
                        ESP_LOGD("rotary_encoder", "alarm is on, show volume");
                        return true;
                      }
                      return false;
                  then:
                    - display.page.show: page12
                    - script.execute:
                        id: reset_page_script
                  else: # browse all pages
                    - if:
                        condition:
                          lambda: |-
                            if (id(rotate_switch_single) == 0 && id(rotate_switch_double) == 0 && id(current_page_id) < 9) {
                              ESP_LOGD("rotary_encoder", "anticlockwise");
                              return true;
                            }
                            return false;
                        then:
                          - if: #dont show special pages
                              condition:
                                display.is_displaying_page:
                                  id: alarmdisplay
                                  page_id: page1
                              then:
                                - display.page.show: page8
                              else:
                                - display.page.show_previous: alarmdisplay
                          - script.execute:
                              id: reset_page_script
                        else: #edit items on page
                          - script.execute:
                              id: rotary_encoder_script
                              clockwise: false
    on_clockwise:
      then:
        - if:
            condition:
              and:
                - switch.is_on: enable_display_on_interaction
                - switch.is_off: display_enabled
            then:
              - switch.turn_on: display_enabled
            else:
              - if:
                  condition:
                    lambda: |-
                      if (id(current_page_id) == 1 && id(alarm_on).state) {
                        ESP_LOGD("rotary_encoder", "alarm is on, show volume");
                        return true;
                      }
                      return false;
                  then:
                    - display.page.show: page12
                    - script.execute:
                        id: reset_page_script
                  else: # browse all pages
                    - if:
                        condition:
                          lambda: |-
                            if (id(rotate_switch_single) == 0 && id(rotate_switch_double) == 0 && id(current_page_id) < 9) {
                              ESP_LOGD("rotary_encoder", "clockwise");
                              return true;
                            }
                            return false;
                        then:
                          - if: #dont show special pages
                              condition:
                                display.is_displaying_page:
                                  id: alarmdisplay
                                  page_id: page8
                              then:
                                - display.page.show: page1
                              else:
                                - display.page.show_next: alarmdisplay
                          - script.execute:
                              id: reset_page_script
                        else: #edit items on page
                          - script.execute:
                              id: rotary_encoder_script
                              clockwise: true
binary_sensor:
  - platform: gpio
    pin:
      number: ${alarm_off_button_pin}
      mode:
        input: true
        pullup: true
      inverted: true
    name: "Alarm off"
    on_multi_click:
      - timing: #long click
        - ON for at least ${alarm_off_button_long_click_time}
        - OFF for at least 0.5s
        then:
          - if:
              condition:
                and:
                  - switch.is_on: enable_display_on_interaction
                  - switch.is_off: display_enabled
              then:
                - switch.turn_on: display_enabled
              else:
                - if:
                    condition:
                      or:
                        - switch.is_on: alarm_on
                        - switch.is_on: snooze_on
                    then:
                      - switch.turn_off: alarm_on
                      - switch.turn_off: snooze_on
                      - switch.turn_off: sleep_timer_on
                    else:
                      - switch.turn_on: alarm_on
                      - if:
                          condition:
                            - switch.is_on: sleep_timer_enabled
                          then:
                            - switch.turn_on: sleep_timer_on  
      - timing: #single click
        - ON for at most ${alarm_off_button_single_click_time}
        - OFF for at least 0.5s
        then:
          - if:
              condition:
                and:
                  - switch.is_on: enable_display_on_interaction
                  - switch.is_off: display_enabled
              then:
                - switch.turn_on: display_enabled
              else:
                - if:
                    condition:
                      and:
                        - switch.is_on: alarm_on
                        - switch.is_off: snooze_on
                        - switch.is_off: sleep_timer_on
                    then:
                      - switch.turn_on: snooze_on
                    else:
                      - if:
                          condition:
                            - switch.is_on: snooze_on
                          then:
                            - switch.turn_off: snooze_on
                          else:
                            - if:
                                condition:
                                  - switch.is_on: sleep_timer_on
                                then:
                                  - switch.turn_off: sleep_timer_on
                                  - switch.turn_off: alarm_on
                                else:
                                  - if:
                                      condition:
                                        and:
                                          - switch.is_off: alarm_on
                                          - switch.is_on: sleep_timer_enabled
                                      then:
                                        - switch.turn_on: alarm_on
                                        - switch.turn_on: sleep_timer_on
                                      else:
                                        - if:
                                            condition:
                                              - switch.is_off: alarm_on
                                            then:
                                              - switch.turn_on: alarm_on
  - platform: gpio
    pin:
      number: ${rotary_button_pin}
      mode: INPUT_PULLUP
      inverted: true
    name: "Rotary Button"
    id: magic_button_board_button
    on_release:
      - logger.log: "Released"
    on_multi_click:
      - timing: # long click
          - ON for at least 2s
          - OFF for at least 0.5s
        then:
          - logger.log: "Long Click"
          - if:
              condition:
                and:
                  - switch.is_on: enable_display_on_interaction
                  - switch.is_off: display_enabled
              then:
                - switch.turn_on: display_enabled
              else:
                - if:
                    condition:
                      display.is_displaying_page: page1
                    then:
                      - display.page.show: page11
                      - script.execute:
                          id: reset_page_script
      - timing: # triple click
          - ON for at most 0.5s
          - OFF for at most 0.5s
          - ON for at most 0.5s
          - OFF for at most 0.5s
          - ON for at most 0.5s
          - OFF for at least 0.5s
        then:
          - logger.log: "Triple Click"
          - if:
              condition:
                and:
                  - switch.is_on: enable_display_on_interaction
                  - switch.is_off: display_enabled
              then:
                - switch.turn_on: display_enabled
              else:
                - if:
                    condition:
                      display.is_displaying_page: page1
                    then:
                      - display.page.show: page12
                      - script.execute:
                          id: reset_page_script
                - if:
                    condition:
                      display.is_displaying_page: page3
                    then:
                      - switch.toggle: ha_1_on
                      - script.execute:
                          id: reset_page_script_no_timeout
                - if:
                    condition:
                      display.is_displaying_page: page4
                    then:
                      - switch.toggle: ha_2_on
                      - script.execute:
                          id: reset_page_script_no_timeout
                - if:
                    condition:
                      display.is_displaying_page: page5
                    then:
                      - switch.toggle: ha_3_on
                      - script.execute:
                          id: reset_page_script_no_timeout
                - if:
                    condition:
                      display.is_displaying_page: page6
                    then:
                      - switch.toggle: ha_4_on
                      - script.execute:
                          id: reset_page_script_no_timeout

      - timing: # double click
          - ON for at most 0.5s
          - OFF for at most 0.5s
          - ON for at most 0.5s
          - OFF for at least 0.5s
        then:
          - logger.log: "Double Click"
          - if:
              condition:
                and:
                  - switch.is_on: enable_display_on_interaction
                  - switch.is_off: display_enabled
              then:
                - switch.turn_on: display_enabled
              else:
                - if:
                    condition:
                      display.is_displaying_page: page1
                    then:
                      - display.page.show: page10
                      - script.execute:
                          id: reset_page_script
                - if:
                    condition:
                      display.is_displaying_page: page2
                    then:
                      - switch.toggle: alarm_enabled
                - if:
                    condition:
                      or:
                        - display.is_displaying_page: page3
                        - display.is_displaying_page: page4
                        - display.is_displaying_page: page5
                        - display.is_displaying_page: page6
                    then:
                      - lambda: |-
                          auto haEnabled = id(ha_1_enabled);
                          auto haAlarmed = id(ha_1_alarmed);
                          int current_page_value = id(current_page_id);
                          if (current_page_value == 4) {
                            haEnabled = id(ha_2_enabled);
                            haAlarmed = id(ha_2_alarmed);
                          }
                          else if (current_page_value == 5) {
                            haEnabled = id(ha_3_enabled);
                            haAlarmed = id(ha_3_alarmed);
                          }
                          else if (current_page_value == 6) {
                            haEnabled = id(ha_4_enabled);
                            haAlarmed = id(ha_4_alarmed);
                          }

                          if (haEnabled->state && haAlarmed->state) {
                            haEnabled->turn_off();
                            haAlarmed->turn_off();
                          }
                          else if (!haEnabled->state && haAlarmed->state) {
                            haAlarmed->turn_off();
                          }
                          else if (!haEnabled->state && !haAlarmed->state) {
                            haEnabled->turn_on();
                          }
                          else if (haEnabled->state && !haAlarmed->state) {
                            haAlarmed->turn_on();
                          }
                          id(reset_page_script).execute();
                - if:
                    condition:
                      display.is_displaying_page: page7
                    then:
                      - switch.toggle: sleep_timer_enabled

      - timing: # single click
          - ON for at most 0.5s
          - OFF for at least 0.5s
        then:
          - logger.log: "Single Click"
          - if:
              condition:
                and:
                  - switch.is_on: enable_display_on_interaction
                  - switch.is_off: display_enabled
              then:
                - switch.turn_on: display_enabled
              else:
                - lambda: |-
                    int current_page_value = id(current_page_id);
                    if (current_page_value == 1) { //clock page
                      if (id(alarm_enabled).state) {
                        id(alarm_enabled).turn_off();
                      }
                      else {
                        id(alarm_enabled).turn_on();
                      }
                    }
                    else if (current_page_value == 2) { //alarm clock page
                      int value = id(rotate_switch_single);
                      value += 1;
                      if (value > 2) {
                        value = 0;
                      }
                      id(rotate_switch_single) = value;
                      if (value == 0) { //not in edit mode, start reset
                        id(reset_page_script).execute();
                      }
                      else {
                        id(reset_page_script).stop();
                      }
                    }
                    else if (current_page_value == 3 || current_page_value == 4 || current_page_value == 5 || current_page_value == 6) { //ha minute page
                      int value = id(rotate_switch_single);
                      value += 1;
                      if (value > 1) {
                        value = 0;
                      }
                      id(rotate_switch_single) = value;
                      if (value == 0) { //not in edit mode, start reset
                        id(reset_page_script).execute();
                      }
                      else {
                        id(reset_page_script).stop();
                      }
                    }
                    else if (current_page_value == 7) { //sleep timer
                      int value = id(rotate_switch_single);
                      value += 1;
                      if (value > 1) {
                        value = 0;
                      }
                      id(rotate_switch_single) = value;
                      if (value == 0) { //not in edit mode, start reset
                        id(reset_page_script).execute();
                      }
                      else {
                        id(reset_page_script).stop();
                      }
                    }
                    else if (current_page_value == 8) { //radio selector
                      int value = id(rotate_switch_single);
                      value += 1;
                      if (value > 1) {
                        value = 0;
                        id(alarm_on).turn_off();
                      }
                      else {
                        id(alarm_on).turn_on();
                      }
                      id(rotate_switch_single) = value;
                      if (value == 0) { //not in edit mode, start reset
                        id(reset_page_script).execute();
                      }
                      else {
                        id(reset_page_script).stop();
                      }
                    }
                    else if (current_page_value == 10 || current_page_value == 12) { //contrast\volume page
                      id(reset_page_script_no_timeout).execute();
                    }
                    else if (current_page_value == 11) { //restart page
                      if (id(rotate_switch_single) == 1) {
                        id(clock_restart_switch).turn_on();
                      }
                      else {
                        id(reset_page_script_no_timeout).execute();
                      }
                    }
                    else if (current_page_value == 12) { //sleep timer page
                      id(reset_page_script_no_timeout).execute();
                    }

select:
  - platform: template
    name: Alarm stream url
    id: alarm_stream_url
    optimistic: true
    restore_value: true
    set_action:
      - media_player.play_media:
          id: media_player_alarm
          media_url: !lambda 'return x.c_str();'
    internal: true
  - platform: template
    name: Alarm stream name
    id: alarm_stream_name
    optimistic: true
    restore_value: true
    set_action:
      - lambda: |-
          ESP_LOGD("alarm_stream_name", "Option %s is selected", x.c_str());
          auto index = id(alarm_stream_name).index_of(x.c_str());
          if (index.has_value()) { //selected value has an index
            ESP_LOGD("alarm_stream_name", "'%s' is at index: %d", x.c_str(), index.value());
            auto option = id(alarm_stream_url).at(index.value());
            if (option.has_value()) { //alarm_stream_url index has been found based on alarm_stream_name
              auto value = option.value();
              ESP_LOGD("alarm_stream_name", "Setting url %s at alarm_stream_url", value.c_str());

              auto alarmStreamUrl = id(alarm_stream_url).make_call();
              alarmStreamUrl.set_option(value.c_str());
              alarmStreamUrl.perform();
            } else {
              ESP_LOGE("alarm_stream_name", "Index %d does not exist at alarm_stream_url", index.has_value());
            }
          } else {
            ESP_LOGE("alarm_stream_name", "There is no option '%s'", x.c_str());
          }
  - platform: template
    name: Alarm buzzer sound
    id: alarm_buzzer_sound
    optimistic: true
    restore_value: true
    set_action:
      - rtttl.stop
      - rtttl.play:
          id: my_rtttl
          rtttl: !lambda "return x;"
    internal: true
  - platform: template
    name: Alarm buzzer name
    id: alarm_buzzer_name
    optimistic: true
    restore_value: true
    set_action:
      - lambda: |-
          ESP_LOGD("alarm_buzzer_name", "Option %s is selected", x.c_str());
          auto index = id(alarm_buzzer_name).index_of(x.c_str());
          if (index.has_value()) { //selected value has an index
            ESP_LOGD("alarm_buzzer_name", "'%s' is at index: %d", x.c_str(), index.value());
            auto option = id(alarm_buzzer_sound).at(index.value());
            if (option.has_value()) { //alarm_buzzer_sound index has been found based on alarm_buzzer_name
              auto value = option.value();
              ESP_LOGD("alarm_buzzer_name", "Setting sound %s at alarm_buzzer_sound", value.c_str());

              auto alarmBuzzerSound = id(alarm_buzzer_sound).make_call();
              alarmBuzzerSound.set_option(value.c_str());
              alarmBuzzerSound.perform();
            } else {
              ESP_LOGE("alarm_buzzer_name", "Index %d does not exist at alarm_buzzer_sound", index.has_value());
            }
          } else {
            ESP_LOGE("alarm_buzzer_name", "There is no option '%s'", x.c_str());
          }    
  - platform: template
    name: Display mode
    id: display_mode
    options:
     - "Full"
     - "Minimum night only"
     - "Minimum night contrast"
     - "Minimum day contrast"
    optimistic: true
    restore_value: true

switch:
  - platform: template
    id: display_enabled
    name: "Display enabled"
    optimistic: true
    restore_mode: RESTORE_DEFAULT_ON
  - platform: template
    id: enable_display_on_interaction
    name: "Enable Display on interaction"
    optimistic: true
    restore_mode: RESTORE_DEFAULT_ON
  - platform: template
    id: alarm_enabled
    name: "Alarm enabled"
    optimistic: true
    restore_mode: RESTORE_DEFAULT_OFF
    entity_category: config
    on_turn_on:
      then:
        - script.execute:
            id: set_alarm_last_off
  - platform: template
    id: snooze_on
    name: "Snooze on"
    optimistic: true
    restore_mode: RESTORE_DEFAULT_OFF
    entity_category: config
    on_turn_on:
      then:
        - if:
            condition:
              lambda: 'return (id(time_sync_done) == true);'
            then:
              - if:
                  condition:
                    and:
                      - switch.is_on: alarm_on
                      - switch.is_off: sleep_timer_on
                  then:
                    - script.execute:
                        id: set_schedule_trigger_time_script
                        index: 6
                    - switch.turn_off: alarm_on
                  else:
                    - switch.turn_off: snooze_on
    on_turn_off:
      - script.execute:
          id: set_snooze_timestamp
          timestamp: 0
  - platform: template
    id: ha_1_enabled
    name: "Home assistant 1 enabled"
    optimistic: true
    restore_mode: RESTORE_DEFAULT_OFF
    entity_category: config
  - platform: template
    id: ha_1_alarmed
    name: "Home assistant 1 alarmed"
    optimistic: true
    restore_mode: RESTORE_DEFAULT_OFF
    entity_category: config
  - platform: template
    id: ha_1_on
    name: "Home Assistant 1 on"
    optimistic: true
    restore_mode: ALWAYS_OFF
    on_turn_on:
      - delay: 60s
      - switch.turn_off: ha_1_on
    entity_category: config
  - platform: template
    id: ha_2_enabled
    name: "Home assistant 2 enabled"
    optimistic: true
    restore_mode: RESTORE_DEFAULT_OFF
    entity_category: config
  - platform: template
    id: ha_2_alarmed
    name: "Home assistant 2 alarmed"
    optimistic: true
    restore_mode: RESTORE_DEFAULT_OFF
    entity_category: config
  - platform: template
    id: ha_2_on
    name: "Home Assistant 2 on"
    optimistic: true
    restore_mode: ALWAYS_OFF
    on_turn_on:
      - delay: 60s
      - switch.turn_off: ha_2_on
    entity_category: config
  - platform: template
    id: ha_3_enabled
    name: "Home assistant 3 enabled"
    optimistic: true
    restore_mode: RESTORE_DEFAULT_OFF
    entity_category: config
  - platform: template
    id: ha_3_alarmed
    name: "Home assistant 3 alarmed"
    optimistic: true
    restore_mode: RESTORE_DEFAULT_OFF
    entity_category: config
  - platform: template
    id: ha_3_on
    name: "Home Assistant 3 on"
    optimistic: true
    restore_mode: ALWAYS_OFF
    on_turn_on:
      - delay: 60s
      - switch.turn_off: ha_3_on
    entity_category: config
  - platform: template
    id: ha_4_enabled
    name: "Home assistant 4 enabled"
    optimistic: true
    restore_mode: RESTORE_DEFAULT_OFF
    entity_category: config
  - platform: template
    id: ha_4_alarmed
    name: "Home assistant 4 alarmed"
    optimistic: true
    restore_mode: RESTORE_DEFAULT_OFF
    entity_category: config
  - platform: template
    id: ha_4_on
    name: "Home Assistant 4 on"
    optimistic: true
    restore_mode: ALWAYS_OFF
    on_turn_on:
      - delay: 60s
      - switch.turn_off: ha_4_on
    entity_category: config
  - platform: template
    id: alarm_on
    name: "Alarm on"
    optimistic: true
    restore_mode: RESTORE_DEFAULT_OFF
    entity_category: config
    on_turn_on:
      then:
      - wait_until:
          lambda: 'return (id(time_sync_done) == true);'
      - switch.turn_on: display_enabled
      - select.set:
          id: display_mode
          option: ${alarm_display_mode}
      - lambda: |-
          //write settings immidiattly, so alarm_on is set if we crashes!
          global_preferences->sync();
          const esphome::optional<std::string> url = id(media_player_alarm).make_call().get_media_url();
          if (url.has_value()) {
            ESP_LOGD("media_player_alarm", "Media has URL");
          }
          else {
            ESP_LOGD("media_player_alarm", "Media has no URL");
            auto mediaPlayerCall = id(media_player_alarm).make_call();
            auto selectState = id(alarm_stream_url).state.c_str();
            mediaPlayerCall.set_media_url(selectState);
            mediaPlayerCall.perform();
            ESP_LOGD("media_player_alarm", "Setting stream url %s", selectState);
          }
    on_turn_off:
      then:
        - switch.turn_off: alarm_on_local
        - if:
            condition:
              lambda: 'return (id(time_sync_done) == true);'
            then:
              - media_player.stop:
        - script.execute:
            id: set_alarm_last_off
            
  - name: "Alarm on local"
    platform: template
    id: alarm_on_local
    optimistic: true
    internal: true
    restore_mode: RESTORE_DEFAULT_OFF
    on_turn_off:
      then:
        - rtttl.stop
    on_turn_on:
      then:    
        - while:
            condition:
              switch.is_on: alarm_on_local
            then:
              # Play the alarm sound on buzzer
              - lambda: |-
                  auto selectState = id(alarm_buzzer_sound).state.c_str();
                  id(my_rtttl).play(selectState);
                  ESP_LOGD("buzzer_alarm", "Playing buzzer sound %s", selectState);
              # Wait until the alarm sound starts playing
              - wait_until:
                  rtttl.is_playing :
              # Wait until the alarm sound stops playing
              - wait_until:
                  not:
                    rtttl.is_playing:

  - platform: restart
    id: clock_restart_switch
    name: "Restart"
  - platform: template
    id: sleep_timer_enabled
    name: "Sleep timer enabled"
    optimistic: true
    restore_mode: RESTORE_DEFAULT_OFF
    entity_category: config
  - platform: template
    id: sleep_timer_on
    name: "Sleep timer on"
    optimistic: true
    restore_mode: RESTORE_DEFAULT_OFF
    entity_category: config
    on_turn_on:
      then:
        - if:
            condition:
              lambda: 'return (id(time_sync_done) == true);'
            then:
              - script.execute:
                  id: set_schedule_trigger_time_script
                  index: 5
    on_turn_off:
      then:
        - if:
            condition:
              lambda: 'return (id(time_sync_done) == true);'
            then:
              - switch.turn_off: alarm_on
              - number.set:
                  id: sleep_timer_timestamp
                  value: 0
  - platform: template
    id: clock_on_display
    name: "Clock on display"
    optimistic: true
    restore_mode: ALWAYS_ON
    entity_category: config

display:
  - platform: ssd1306_i2c
    id: alarmdisplay
    model: ${display_model}
    #reset_pin: D0
    address: 0x3C
    rotation: ${display_rotation}
    contrast: 1
    update_interval: 500ms
    pages:
      - id: page1 #clock page
        lambda: |-
          if (!id(display_enabled).state) {
            // Turn the whole display off
            it.fill(COLOR_OFF);
            return;
          }
          auto time = id(ntp).now();
          time_t currentTime = time.timestamp;
          char seconds[15];
          strftime(seconds, sizeof(seconds), "%S", localtime(&currentTime));
          int shouldBlink = atoi(seconds) % 2;
          bool is_night_mode = !id(time_sunrise);
          bool showClock = id(clock_on_display).state;

          auto index = id(display_mode).active_index();
          int displayMode = 0;
          if (index.has_value()) {
            if (index.value() == 1 && is_night_mode) {
              //minimum night only
              displayMode = 1;
            }
            else if (index.value() == 2) {
              //minimum night contrast
              displayMode = 2;
            }
            else if (index.value() == 3) {
              //minimum day contrast
              displayMode = 3;
            }            
          }

          //determine font
          auto timeFont51 = id(robotomedium51);
          auto timeFont20 = id(robotomedium20);
          if (displayMode == 1 || displayMode == 2 || displayMode == 3) {
            timeFont51 = id(robotothin51);
            timeFont20 = id(robotothin20);
          }

          if ((is_night_mode && displayMode == 1) || displayMode == 2) {
            alarmdisplay->set_contrast(id(screen_contrast_night).state/100);
          }
          else {
            alarmdisplay->set_contrast(id(screen_contrast_day).state/100);
          }

          //status bar
          if (id(alarm_on).state && !id(sleep_timer_on).state) {
            if (shouldBlink) {
              it.printf(0, 0, id(robotomedium20), TextAlign::LEFT, "\U000F0E71");
            }
          }
          else if (id(alarm_enabled).state) {
            it.printf(0, 0, id(robotomedium20), TextAlign::LEFT, "\U000F0020");
          }

          //snooze
          if (id(snooze_on).state) {
            it.printf(27, 0, id(robotomedium20), TextAlign::LEFT, "\U000F068E");
          }

          //ha
          int calculated_width;
          int calculated_height;
          int calculated_x;
          int calculated_y;
          std::string displayString = "\U000F07D0";
          if (id(api_connected)) {
            int leftBase = it.get_width()/2;
            int iconLeftRightMargin = 2;
            int iconTopMargin = 4;
            int iconBottomMargin = 3;

            it.get_text_bounds(0, 0, displayString.c_str(), id(robotomedium30), TextAlign::CENTER, &calculated_x, &calculated_y, &calculated_width, &calculated_height); //calculate icon dimensions
            int iconHeightHalf = (calculated_height/2)-5; //a small correction due to CENTER being used as alignment
            //show ha icon
            it.printf(leftBase, iconHeightHalf, id(robotomedium20), TextAlign::CENTER, "\U000F07D0");

            //hide the part that is disabled
            if ((!id(ha_1_on).state && id(ha_1_enabled).state && ((id(alarm_enabled).state && id(ha_1_alarmed).state) || !id(ha_1_alarmed).state)) || (id(ha_1_on).state && shouldBlink)) {
              //the icon should be visible
            }
            else {
                it.printf(leftBase+iconLeftRightMargin, iconHeightHalf+iconBottomMargin, id(robotomedium15), COLOR_OFF, TextAlign::BOTTOM_RIGHT, "\U000F0764");
            }
            if ((!id(ha_2_on).state && id(ha_2_enabled).state && ((id(alarm_enabled).state && id(ha_2_alarmed).state) || !id(ha_2_alarmed).state)) || (id(ha_2_on).state && shouldBlink)) {
              //the icon should be visible
            }
            else {
                it.printf(leftBase-iconLeftRightMargin, iconHeightHalf+iconBottomMargin, id(robotomedium15), COLOR_OFF, TextAlign::BOTTOM_LEFT, "\U000F0764");
            }
            if ((!id(ha_3_on).state && id(ha_3_enabled).state && ((id(alarm_enabled).state && id(ha_3_alarmed).state) || !id(ha_3_alarmed).state)) || (id(ha_3_on).state && shouldBlink)) {
              //the icon should be visible
            }
            else {
              it.printf(leftBase+iconLeftRightMargin, iconHeightHalf-iconTopMargin, id(robotomedium15), COLOR_OFF, TextAlign::TOP_RIGHT, "\U000F0764");
            }
            if ((!id(ha_4_on).state && id(ha_4_enabled).state && ((id(alarm_enabled).state && id(ha_4_alarmed).state) || !id(ha_4_alarmed).state)) || (id(ha_4_on).state && shouldBlink)) {
              //the icon should be visible
            }
            else {
              it.printf(leftBase-iconLeftRightMargin, iconHeightHalf-iconTopMargin, id(robotomedium15), COLOR_OFF, TextAlign::TOP_LEFT, "\U000F0764");
            }
          }
          else {
            it.printf(it.get_width()/2, 0, id(robotomedium20), TextAlign::TOP_CENTER, "\U000F1A47");
          }

          //sleep timer
          if ((!id(sleep_timer_on).state && id(sleep_timer_enabled).state) || (id(sleep_timer_on).state && shouldBlink)) {
            it.printf((it.get_width()/2)+16, 0, id(robotomedium20), TextAlign::LEFT, "\U000F1ADD");
          }

          //wifi
          if (isnan(id(wifi_signal_percent).state)) {
            it.printf(it.get_width(), 0, id(robotomedium20), TextAlign::RIGHT, "\U000F092E"); // WifiStrengthOffOutline
          }
          else if (displayMode == 0) {
            int wifiStrength = id(wifi_signal_percent).state;
            if (wifiStrength > 75) {
              it.printf(it.get_width(), 0, id(robotomedium20), TextAlign::RIGHT, "\U000F0928"); // WifiStrength4
            }
            else if (wifiStrength > 50) {
              it.printf(it.get_width(), 0, id(robotomedium20), TextAlign::RIGHT, "\U000F0925"); // WifiStrength3
            }
            else if (wifiStrength > 30) {
              it.printf(it.get_width(), 0, id(robotomedium20), TextAlign::RIGHT, "\U000F0922"); // WifiStrength2
            }
            else if (wifiStrength > 10) {
              it.printf(it.get_width(), 0, id(robotomedium20), TextAlign::RIGHT, "\U000F091F"); // WifiStrength1
            }
            else {
              it.printf(it.get_width(), 0, id(robotomedium20), TextAlign::RIGHT, "\U000F092F"); // WifiStrengthOutline
            }
          }

          if (it.get_width() == 128 && it.get_height() == 128) { //sh1107
            //it.strftime(0, (it.get_width()/2)-10, timeFont20, TextAlign::BOTTOM_LEFT, "%a", time);
            
            // ESPTime in struct tm umwandeln (kein Pointer!)
            struct tm c_time = time.to_c_tm();
            
            // Englischen Wochentag abfragen
            char buffer[4];
            strftime(buffer, sizeof(buffer), "%a", &c_time);
            
            // Deutsche Kürzel zuweisen
            std::string tag;
            if (strcmp(buffer, "Sun") == 0) tag = "So";
            else if (strcmp(buffer, "Mon") == 0) tag = "Mo";
            else if (strcmp(buffer, "Tue") == 0) tag = "Di";
            else if (strcmp(buffer, "Wed") == 0) tag = "Mi";
            else if (strcmp(buffer, "Thu") == 0) tag = "Do";
            else if (strcmp(buffer, "Fri") == 0) tag = "Fr";
            else if (strcmp(buffer, "Sat") == 0) tag = "Sa";
            else tag = buffer;  // fallback
            
            // Anzeige
            it.print(0, (it.get_width()/2)-10, timeFont20, TextAlign::BOTTOM_LEFT, tag.c_str());

            it.strftime(0, (it.get_width()/2)-10, timeFont20, TextAlign::TOP_LEFT, "%d-%m", time);

            string preZeroHour = "";
            string preZeroMinute = "";
            if (id(alarm_enabled).state && !id(snooze_on).state) {
              if (id(alarm_hour).state < 10) {
                preZeroHour = "0";
              }
              if (id(alarm_minute).state < 10) {
                preZeroMinute = "0";
              }
              it.printf(it.get_width(), (it.get_height()/2), timeFont20, TextAlign::CENTER_RIGHT, "%s%i:%s%i", preZeroHour.c_str(), (int)id(alarm_hour).state, preZeroMinute.c_str(), (int)id(alarm_minute).state);
            }
            else if (id(alarm_enabled).state && id(snooze_on).state) {
              time_t snoozeTime = id(snooze_timestamp);
              char strForDisplay[6];
              strftime(strForDisplay, sizeof(strForDisplay), "%H:%M", localtime(&snoozeTime));
              it.printf(it.get_width(), (it.get_height()/2), timeFont20, TextAlign::CENTER_RIGHT, "%s", strForDisplay);
            }
          }
          //end statusbar

          if (showClock) {
            //the font will be placed too high by default
            int fontMarginBottomCorrection = 10;

            displayString = ":";
            int timeY = it.get_height();
            timeY = (timeY + fontMarginBottomCorrection);
            it.get_text_bounds(0, 0, displayString.c_str(), timeFont51, TextAlign::TOP_CENTER, &calculated_x, &calculated_y, &calculated_width, &calculated_height); //calculate second indicator width

            if(!id(time_sync_done)) {
              it.print(it.get_width()/2, timeY, timeFont51, TextAlign::BOTTOM_CENTER, ".....");
            }
            else {
              it.strftime((it.get_width()/2)-(calculated_width/2), timeY, timeFont51, TextAlign::BOTTOM_RIGHT, "%H", time);
              if((displayMode == 1 || displayMode == 2 || displayMode == 3) || shouldBlink) {
                it.printf((it.get_width()/2), timeY, timeFont51, TextAlign::BOTTOM_CENTER, ":");
              }
              it.strftime((it.get_width()/2)+(calculated_width/2), timeY, timeFont51, TextAlign::BOTTOM_LEFT, "%M", time);
            }
          }

          id(current_page_id) = 1;
      - id: page2 #Alarm clock setting page
        lambda: |-
          if (!id(display_enabled).state) {
            // Turn the whole display off
            it.fill(COLOR_OFF);
            return;
          }
          auto time = id(ntp).now();
          time_t currentTime = time.timestamp;
          char seconds[15];
          strftime(seconds, sizeof(seconds), "%S", localtime(&currentTime));
          int shouldBlink = atoi(seconds) % 2;

          int calculated_width;
          int calculated_height;
          int calculated_x;
          int calculated_y;
          std::string timeString = ":";
          int timeY = it.get_height();
          it.get_text_bounds(0, 0, timeString.c_str(), id(robotomedium30), TextAlign::TOP_CENTER, &calculated_x, &calculated_y, &calculated_width, &calculated_height); //calculate second indicator width
          int indicatorWidth = calculated_width;

          //alarm clock icon
          it.printf(0, (it.get_height()/2), id(robotomedium20), TextAlign::CENTER_LEFT, "\U000F0020");

          //alarm clock
          int rotate_switch_single_value = id(rotate_switch_single);

          if ((shouldBlink && rotate_switch_single_value == 1) || rotate_switch_single_value != 1) {
            if (id(alarm_hour).state > 9) {
              it.printf((it.get_width()/2)-(indicatorWidth/2), (it.get_height()/2), id(robotomedium30), TextAlign::CENTER_RIGHT, "%i", (int)id(alarm_hour).state);
            }
            else {
              it.printf((it.get_width()/2)-(indicatorWidth/2), (it.get_height()/2), id(robotomedium30), TextAlign::CENTER_RIGHT, "0%i", (int)id(alarm_hour).state);
            }
          }
          it.printf((it.get_width()/2), (it.get_height()/2), id(robotomedium30), TextAlign::CENTER, ":");
          if ((shouldBlink && rotate_switch_single_value == 2) || rotate_switch_single_value != 2) {
            if (id(alarm_minute).state > 9) {
              it.printf((it.get_width()/2)+(indicatorWidth/2), (it.get_height()/2), id(robotomedium30), TextAlign::CENTER_LEFT, "%i", (int)id(alarm_minute).state);
            }
            else {
              it.printf((it.get_width()/2)+(indicatorWidth/2), (it.get_height()/2), id(robotomedium30), TextAlign::CENTER_LEFT, "0%i", (int)id(alarm_minute).state);
            }
          }

          if (id(alarm_enabled).state) {
            it.printf(it.get_width(), (it.get_height()/2), id(robotomedium20), TextAlign::CENTER_RIGHT, "\U000F0C52");
          }
          else {
            it.printf(it.get_width(), (it.get_height()/2), id(robotomedium20), TextAlign::CENTER_RIGHT, "\U000F0131");
          }

          id(current_page_id) = 2;
      - id: page3 #HA 1 page
        lambda: |-
          if (!id(display_enabled).state) {
            // Turn the whole display off
            it.fill(COLOR_OFF);
            return;
          }
          //https://gist.github.com/alvesvaren/767d9585f0ecbef18ef1c7c0492c4332
          auto time = id(ntp).now();
          time_t currentTime = time.timestamp;
          char seconds[15];
          strftime(seconds, sizeof(seconds), "%S", localtime(&currentTime));
          int shouldBlink = atoi(seconds) % 2;
          int ha_value = id(ha_1_pre_minute).state;
          int rotate_switch_single_value = id(rotate_switch_single);

          it.printf(it.get_width()/2, 0, id(robotomedium20), TextAlign::TOP_CENTER, "HA 1");

          //the font will be placed too high by default
          int fontMarginBottomCorrection = 10;

          int calculated_width;
          int calculated_height;
          int calculated_x;
          int calculated_y;
          std::string displayString = "\U000F07D0";
          it.get_text_bounds(0, 0, displayString.c_str(), id(robotomedium30), TextAlign::TOP_CENTER, &calculated_x, &calculated_y, &calculated_width, &calculated_height); //calculate icon dimensions
          int iconWidthHalf = calculated_width/2;

          //ha icon
          it.printf(iconWidthHalf, it.get_height()/2, id(robotomedium20), TextAlign::CENTER, "\U000F07D0");

          int iconLeftRightMargin = 2;
          int iconTopMargin = 4;
          int iconBottomMargin = 3;

          //ha icon hide
          if (shouldBlink) {
            //it.printf(iconWidthHalf+iconLeftRightMargin, (it.get_height()/2)+iconBottomMargin, id(robotomedium15), COLOR_OFF, TextAlign::BOTTOM_RIGHT, "\U000F0764");
            it.printf(iconWidthHalf-iconLeftRightMargin, (it.get_height()/2)+iconBottomMargin, id(robotomedium15), COLOR_OFF, TextAlign::BOTTOM_LEFT, "\U000F0764");
            it.printf(iconWidthHalf+iconLeftRightMargin, (it.get_height()/2)-iconTopMargin, id(robotomedium15), COLOR_OFF, TextAlign::TOP_RIGHT, "\U000F0764");
            it.printf(iconWidthHalf-iconLeftRightMargin, (it.get_height()/2)-iconTopMargin, id(robotomedium15), COLOR_OFF, TextAlign::TOP_LEFT, "\U000F0764");
          }

          //ha value
          if ((shouldBlink && rotate_switch_single_value == 1) || rotate_switch_single_value != 1) {
            if (it.get_width() == 128 && it.get_height() == 128) { //sh1107
              it.printf((it.get_width()/2), (it.get_height()/2), id(robotomedium40), TextAlign::CENTER, "%i", (int)ha_value);
            }
            else {
              it.printf((it.get_width()/2), it.get_height()+fontMarginBottomCorrection, id(robotomedium40), TextAlign::BOTTOM_CENTER, "%i", (int)ha_value);
            }
          }

          //ha enabled
          if (id(ha_1_enabled).state) {
            it.printf(it.get_width(), (it.get_height()/2), id(robotomedium20), TextAlign::CENTER_RIGHT, "\U000F0C52");
          }
          else {
            it.printf(it.get_width(), (it.get_height()/2), id(robotomedium20), TextAlign::CENTER_RIGHT, "\U000F0131");
          }

          //ha alarmed
          it.get_text_bounds(0, 0, displayString.c_str(), id(robotomedium20), TextAlign::TOP_CENTER, &calculated_x, &calculated_y, &calculated_width, &calculated_height); //calculate icon dimensions
          if (id(ha_1_alarmed).state) {
            it.printf(it.get_width(), (it.get_height()/2)+calculated_height, id(robotomedium20), TextAlign::CENTER_RIGHT, "\U000F0021");
          }
          else {
            it.printf(it.get_width(), (it.get_height()/2)+calculated_height, id(robotomedium20), TextAlign::CENTER_RIGHT, "\U000F0023");
          }

          id(current_page_id) = 3;
      - id: page4 #HA 2 page
        lambda: |-
          if (!id(display_enabled).state) {
            // Turn the whole display off
            it.fill(COLOR_OFF);
            return;
          }
          auto time = id(ntp).now();
          time_t currentTime = time.timestamp;
          char seconds[15];
          strftime(seconds, sizeof(seconds), "%S", localtime(&currentTime));
          int shouldBlink = atoi(seconds) % 2;
          int ha_value = id(ha_2_pre_minute).state;
          int rotate_switch_single_value = id(rotate_switch_single);

          it.printf(it.get_width()/2, 0, id(robotomedium20), TextAlign::TOP_CENTER, "HA 2");

          //the font will be placed too high by default
          int fontMarginBottomCorrection = 10;

          int calculated_width;
          int calculated_height;
          int calculated_x;
          int calculated_y;
          std::string displayString = "\U000F07D0";
          it.get_text_bounds(0, 0, displayString.c_str(), id(robotomedium30), TextAlign::TOP_CENTER, &calculated_x, &calculated_y, &calculated_width, &calculated_height); //calculate icon dimensions
          int iconWidthHalf = calculated_width/2;

          //ha icon
          it.printf(iconWidthHalf, it.get_height()/2, id(robotomedium20), TextAlign::CENTER, "\U000F07D0");

          int iconLeftRightMargin = 2;
          int iconTopMargin = 4;
          int iconBottomMargin = 3;

          //ha icon hide
          if (shouldBlink) {
            it.printf(iconWidthHalf+iconLeftRightMargin, (it.get_height()/2)+iconBottomMargin, id(robotomedium15), COLOR_OFF, TextAlign::BOTTOM_RIGHT, "\U000F0764");
            //it.printf(iconWidthHalf-iconLeftRightMargin, (it.get_height()/2)+iconBottomMargin, id(robotomedium15), COLOR_OFF, TextAlign::BOTTOM_LEFT, "\U000F0764");
            it.printf(iconWidthHalf+iconLeftRightMargin, (it.get_height()/2)-iconTopMargin, id(robotomedium15), COLOR_OFF, TextAlign::TOP_RIGHT, "\U000F0764");
            it.printf(iconWidthHalf-iconLeftRightMargin, (it.get_height()/2)-iconTopMargin, id(robotomedium15), COLOR_OFF, TextAlign::TOP_LEFT, "\U000F0764");
          }

          //ha value
          if ((shouldBlink && rotate_switch_single_value == 1) || rotate_switch_single_value != 1) {
            if (it.get_width() == 128 && it.get_height() == 128) { //sh1107
              it.printf((it.get_width()/2), (it.get_height()/2), id(robotomedium40), TextAlign::CENTER, "%i", (int)ha_value);
            }
            else {
              it.printf((it.get_width()/2), it.get_height()+fontMarginBottomCorrection, id(robotomedium40), TextAlign::BOTTOM_CENTER, "%i", (int)ha_value);
            }
          }

          //ha enabled
          if (id(ha_2_enabled).state) {
            it.printf(it.get_width(), (it.get_height()/2), id(robotomedium20), TextAlign::CENTER_RIGHT, "\U000F0C52");
          }
          else {
            it.printf(it.get_width(), (it.get_height()/2), id(robotomedium20), TextAlign::CENTER_RIGHT, "\U000F0131");
          }

          //ha alarmed
          it.get_text_bounds(0, 0, displayString.c_str(), id(robotomedium20), TextAlign::TOP_CENTER, &calculated_x, &calculated_y, &calculated_width, &calculated_height); //calculate icon dimensions
          if (id(ha_2_alarmed).state) {
            it.printf(it.get_width(), (it.get_height()/2)+calculated_height, id(robotomedium20), TextAlign::CENTER_RIGHT, "\U000F0021");
          }
          else {
            it.printf(it.get_width(), (it.get_height()/2)+calculated_height, id(robotomedium20), TextAlign::CENTER_RIGHT, "\U000F0023");
          }

          id(current_page_id) = 4;
      - id: page5 #HA 3 page
        lambda: |-
          if (!id(display_enabled).state) {
            // Turn the whole display off
            it.fill(COLOR_OFF);
            return;
          }
          auto time = id(ntp).now();
          time_t currentTime = time.timestamp;
          char seconds[15];
          strftime(seconds, sizeof(seconds), "%S", localtime(&currentTime));
          int shouldBlink = atoi(seconds) % 2;
          int ha_value = id(ha_3_pre_minute).state;
          int rotate_switch_single_value = id(rotate_switch_single);

          it.printf(it.get_width()/2, 0, id(robotomedium20), TextAlign::TOP_CENTER, "HA 3");

          //the font will be placed too high by default
          int fontMarginBottomCorrection = 10;

          int calculated_width;
          int calculated_height;
          int calculated_x;
          int calculated_y;
          std::string displayString = "\U000F07D0";
          it.get_text_bounds(0, 0, displayString.c_str(), id(robotomedium30), TextAlign::TOP_CENTER, &calculated_x, &calculated_y, &calculated_width, &calculated_height); //calculate icon dimensions
          int iconWidthHalf = calculated_width/2;

          //ha icon
          it.printf(iconWidthHalf, it.get_height()/2, id(robotomedium20), TextAlign::CENTER, "\U000F07D0");

          int iconLeftRightMargin = 2;
          int iconTopMargin = 4;
          int iconBottomMargin = 3;

          //ha icon hide
          if (shouldBlink) {
            it.printf(iconWidthHalf+iconLeftRightMargin, (it.get_height()/2)+iconBottomMargin, id(robotomedium15), COLOR_OFF, TextAlign::BOTTOM_RIGHT, "\U000F0764");
            it.printf(iconWidthHalf-iconLeftRightMargin, (it.get_height()/2)+iconBottomMargin, id(robotomedium15), COLOR_OFF, TextAlign::BOTTOM_LEFT, "\U000F0764");
            //it.printf(iconWidthHalf+iconLeftRightMargin, (it.get_height()/2)-iconTopMargin, id(robotomedium15), COLOR_OFF, TextAlign::TOP_RIGHT, "\U000F0764");
            it.printf(iconWidthHalf-iconLeftRightMargin, (it.get_height()/2)-iconTopMargin, id(robotomedium15), COLOR_OFF, TextAlign::TOP_LEFT, "\U000F0764");
          }

          //ha value
          if ((shouldBlink && rotate_switch_single_value == 1) || rotate_switch_single_value != 1) {
            if (it.get_width() == 128 && it.get_height() == 128) { //sh1107
              it.printf((it.get_width()/2), (it.get_height()/2), id(robotomedium40), TextAlign::CENTER, "%i", (int)ha_value);
            }
            else {
              it.printf((it.get_width()/2), it.get_height()+fontMarginBottomCorrection, id(robotomedium40), TextAlign::BOTTOM_CENTER, "%i", (int)ha_value);
            }
          }

          //ha enabled
          if (id(ha_3_enabled).state) {
            it.printf(it.get_width(), (it.get_height()/2), id(robotomedium20), TextAlign::CENTER_RIGHT, "\U000F0C52");
          }
          else {
            it.printf(it.get_width(), (it.get_height()/2), id(robotomedium20), TextAlign::CENTER_RIGHT, "\U000F0131");
          }

          //ha alarmed
          it.get_text_bounds(0, 0, displayString.c_str(), id(robotomedium20), TextAlign::TOP_CENTER, &calculated_x, &calculated_y, &calculated_width, &calculated_height); //calculate icon dimensions
          if (id(ha_3_alarmed).state) {
            it.printf(it.get_width(), (it.get_height()/2)+calculated_height, id(robotomedium20), TextAlign::CENTER_RIGHT, "\U000F0021");
          }
          else {
            it.printf(it.get_width(), (it.get_height()/2)+calculated_height, id(robotomedium20), TextAlign::CENTER_RIGHT, "\U000F0023");
          }

          id(current_page_id) = 5;
      - id: page6 #HA 4 page
        lambda: |-
          if (!id(display_enabled).state) {
            // Turn the whole display off
            it.fill(COLOR_OFF);
            return;
          }
          auto time = id(ntp).now();
          time_t currentTime = time.timestamp;
          char seconds[15];
          strftime(seconds, sizeof(seconds), "%S", localtime(&currentTime));
          int shouldBlink = atoi(seconds) % 2;
          int ha_value = id(ha_4_pre_minute).state;
          int rotate_switch_single_value = id(rotate_switch_single);

          it.printf(it.get_width()/2, 0, id(robotomedium20), TextAlign::TOP_CENTER, "HA 4");

          //the font will be placed too high by default
          int fontMarginBottomCorrection = 10;

          int calculated_width;
          int calculated_height;
          int calculated_x;
          int calculated_y;
          std::string displayString = "\U000F07D0";
          it.get_text_bounds(0, 0, displayString.c_str(), id(robotomedium30), TextAlign::TOP_CENTER, &calculated_x, &calculated_y, &calculated_width, &calculated_height); //calculate icon dimensions
          int iconWidthHalf = calculated_width/2;

          //ha icon
          it.printf(iconWidthHalf, it.get_height()/2, id(robotomedium20), TextAlign::CENTER, "\U000F07D0");

          int iconLeftRightMargin = 2;
          int iconTopMargin = 4;
          int iconBottomMargin = 3;

          //ha icon hide
          if (shouldBlink) {
            it.printf(iconWidthHalf+iconLeftRightMargin, (it.get_height()/2)+iconBottomMargin, id(robotomedium15), COLOR_OFF, TextAlign::BOTTOM_RIGHT, "\U000F0764");
            it.printf(iconWidthHalf-iconLeftRightMargin, (it.get_height()/2)+iconBottomMargin, id(robotomedium15), COLOR_OFF, TextAlign::BOTTOM_LEFT, "\U000F0764");
            it.printf(iconWidthHalf+iconLeftRightMargin, (it.get_height()/2)-iconTopMargin, id(robotomedium15), COLOR_OFF, TextAlign::TOP_RIGHT, "\U000F0764");
            //it.printf(iconWidthHalf-iconLeftRightMargin, (it.get_height()/2)-iconTopMargin, id(robotomedium15), COLOR_OFF, TextAlign::TOP_LEFT, "\U000F0764");
          }

          //ha value
          if ((shouldBlink && rotate_switch_single_value == 1) || rotate_switch_single_value != 1) {
            if (it.get_width() == 128 && it.get_height() == 128) { //sh1107
              it.printf((it.get_width()/2), (it.get_height()/2), id(robotomedium40), TextAlign::CENTER, "%i", (int)ha_value);
            }
            else {
              it.printf((it.get_width()/2), it.get_height()+fontMarginBottomCorrection, id(robotomedium40), TextAlign::BOTTOM_CENTER, "%i", (int)ha_value);
            }
          }

          //ha enabled
          if (id(ha_4_enabled).state) {
            it.printf(it.get_width(), (it.get_height()/2), id(robotomedium20), TextAlign::CENTER_RIGHT, "\U000F0C52");
          }
          else {
            it.printf(it.get_width(), (it.get_height()/2), id(robotomedium20), TextAlign::CENTER_RIGHT, "\U000F0131");
          }

          //ha alarmed
          it.get_text_bounds(0, 0, displayString.c_str(), id(robotomedium20), TextAlign::TOP_CENTER, &calculated_x, &calculated_y, &calculated_width, &calculated_height); //calculate icon dimensions
          if (id(ha_4_alarmed).state) {
            it.printf(it.get_width(), (it.get_height()/2)+calculated_height, id(robotomedium20), TextAlign::CENTER_RIGHT, "\U000F0021");
          }
          else {
            it.printf(it.get_width(), (it.get_height()/2)+calculated_height, id(robotomedium20), TextAlign::CENTER_RIGHT, "\U000F0023");
          }

          id(current_page_id) = 6;
      - id: page7 #Sleep timer
        lambda: |-
          if (!id(display_enabled).state) {
            // Turn the whole display off
            it.fill(COLOR_OFF);
            return;
          }
          auto time = id(ntp).now();
          time_t currentTime = time.timestamp;
          char seconds[15];
          strftime(seconds, sizeof(seconds), "%S", localtime(&currentTime));
          int shouldBlink = atoi(seconds) % 2;
          int sleep_timer_duration_value = id(sleep_timer_duration).state;
          int rotate_switch_single_value = id(rotate_switch_single);

          it.printf(0, (it.get_height()/2), id(robotomedium20), TextAlign::CENTER_LEFT, "\U000F1ADD");

          if ((shouldBlink && rotate_switch_single_value == 1) || rotate_switch_single_value != 1) {
            it.printf(it.get_width()/2, (it.get_height()/2), id(robotomedium40), TextAlign::CENTER, "%i", sleep_timer_duration_value);
          }

          if (id(sleep_timer_enabled).state) {
            it.printf(it.get_width(), (it.get_height()/2), id(robotomedium20), TextAlign::CENTER_RIGHT, "\U000F0C52");
          }
          else {
            it.printf(it.get_width(), (it.get_height()/2), id(robotomedium20), TextAlign::CENTER_RIGHT, "\U000F0131");
          }

          id(current_page_id) = 7;
      - id: page8 #Radio selector
        lambda: |-
          if (!id(display_enabled).state) {
            // Turn the whole display off
            it.fill(COLOR_OFF);
            return;
          }
          auto time = id(ntp).now();
          time_t currentTime = time.timestamp;
          char seconds[15];
          strftime(seconds, sizeof(seconds), "%S", localtime(&currentTime));
          int shouldBlink = atoi(seconds) % 2;

          int rotate_switch_single_value = id(rotate_switch_single);

          std::string radioValue = "Unknown";
          auto index = id(alarm_stream_url).active_index();
          if (index.has_value()) {
            auto option = id(alarm_stream_name).at(index.value());
            if (option.has_value()) {
              radioValue = option.value();
            } else {
              ESP_LOGE("alarmdisplay", "Index %d does not exist", index.value());
            }
          } else {
            ESP_LOGE("alarmdisplay", "There is no active index at alarm_stream_url");
          }

          it.printf(it.get_width()/2, 0, id(robotomedium20), TextAlign::TOP_CENTER, "Radio");

          if ((shouldBlink && rotate_switch_single_value == 1) || rotate_switch_single_value != 1) {
            it.printf(it.get_width()/2, it.get_height(), id(robotomedium20), TextAlign::BOTTOM_CENTER, radioValue.c_str());
          }

          id(current_page_id) = 8;
      - id: page10 #Contrast page
        lambda: |-
          if (!id(display_enabled).state) {
            // Turn the whole display off
            it.fill(COLOR_OFF);
            return;
          }
          bool is_night_mode = !id(time_sunrise);

          if (!is_night_mode) {
            alarmdisplay->set_contrast(id(screen_contrast_day).state/100);
          }
          else {
            alarmdisplay->set_contrast(id(screen_contrast_night).state/100);
          }

          it.printf(0, (it.get_height()/2), id(robotomedium20), TextAlign::CENTER_LEFT, "\U000F0197");
          int value = 0;
          if (!is_night_mode) {
            value = id(screen_contrast_day).state;
          }
          else {
            value = id(screen_contrast_night).state;
          }
          ESP_LOGD("alarmdisplay", "Current contrast %i", value);
          it.printf(it.get_width()/2, (it.get_height()/2), id(robotomedium40), TextAlign::CENTER, "%i", value);

          id(current_page_id) = 10;
      - id: page11 #Restart page
        lambda: |-
          if (!id(display_enabled).state) {
            // Turn the whole display off
            it.fill(COLOR_OFF);
            return;
          }
          it.printf(it.get_width()/2, 0, id(robotomedium20), TextAlign::TOP_CENTER, "Restart?");
          if (id(rotate_switch_single) == 0) { // check active
            it.printf(it.get_width()/2, it.get_height(), id(robotomedium40), TextAlign::BOTTOM_RIGHT, "\U000F0C52");
            it.printf(it.get_width()/2, it.get_height(), id(robotomedium40), TextAlign::BOTTOM_LEFT, "\U000F0157");
          }
          else { //close active
            it.printf(it.get_width()/2, it.get_height(), id(robotomedium40), TextAlign::BOTTOM_RIGHT, "\U000F0132");
            it.printf(it.get_width()/2, it.get_height(), id(robotomedium40), TextAlign::BOTTOM_LEFT, "\U000F0158");
          }

          id(current_page_id) = 11;
      - id: page12 #Volume page
        lambda: |-
          if (!id(display_enabled).state) {
            // Turn the whole display off
            it.fill(COLOR_OFF);
            return;
          }
          it.printf(0, (it.get_height()/2), id(robotomedium20), TextAlign::CENTER_LEFT, "\U000F057E");
          int value = id(alarm_volume).state;
          it.printf(it.get_width()/2, (it.get_height()/2), id(robotomedium40), TextAlign::CENTER, "%i", value);
          id(current_page_id) = 12;

script:
  - id: rotary_encoder_script
    mode: queued
    parameters:
      clockwise: bool
    then:
      - lambda: |-
          std::string rotation = "on_clockwise";
          if (clockwise == false) {
            rotation = "on_anticlockwise";
          }

          int current_page_id_value = id(current_page_id);
          int rotate_switch_single_value = id(rotate_switch_single);
          int rotate_switch_double_value = id(rotate_switch_double);

          //ESP_LOGD("rotary_encoder_script", "Current page id %i", current_page_id_value);

          if (current_page_id_value == 2) { //alarm clock page
            int hour_value = id(alarm_hour).state;
            int minute_value = id(alarm_minute).state;
            if (rotate_switch_single_value == 1) { //update minutes
              if (clockwise == true) {
                hour_value += 1;
                if (hour_value > 23) {
                  hour_value = 0;
                }
              }
              else {
                hour_value -= 1;
                if (hour_value < 0) {
                  hour_value = 23;
                }
              }
              auto call = id(alarm_hour).make_call();
              call.set_value(hour_value);
              call.perform();
              ESP_LOGD("rotary_encoder_script", "%s setting alarm_hour to %i", rotation.c_str(), hour_value);
            }
            else if (rotate_switch_single_value == 2) { //update minute
              if (clockwise == true) {
                minute_value += 1;
                if (minute_value > 59) {
                  minute_value = 0;
                }
              }
              else {
                minute_value -= 1;
                if (minute_value < 0) {
                  minute_value = 59;
                }
              }
              auto call = id(alarm_minute).make_call();
              call.set_value(minute_value);
              call.perform();
              ESP_LOGD("rotary_encoder_script", "%s setting alarm_minute to %i", rotation.c_str(), alarm_minute);
            }
          }
          else if (current_page_id_value == 3 || current_page_id_value == 4 || current_page_id_value == 5 || current_page_id_value == 6) { //ha pages
            int ha_value = 0;
            if (current_page_id_value == 3) {
              ha_value = id(ha_1_pre_minute).state;
            }
            else if (current_page_id_value == 4) {
              ha_value = id(ha_2_pre_minute).state;
            }
            else if (current_page_id_value == 5) {
              ha_value = id(ha_3_pre_minute).state;
            }
            else if (current_page_id_value == 6) {
              ha_value = id(ha_4_pre_minute).state;
            }
            if (rotate_switch_single_value == 1) { //update ha minutes
              if (clockwise) {
                ha_value += 1;
                if (ha_value > 99) {
                  ha_value = -99;
                }
              }
              else {
                ha_value -= 1;
                if (ha_value < -99) {
                  ha_value = 99;
                }
              }

              if (current_page_id_value == 3) {
                auto call = id(ha_1_pre_minute).make_call();
                call.set_value(ha_value);
                call.perform();
              }
              else if (current_page_id_value == 4) {
                auto call = id(ha_2_pre_minute).make_call();
                call.set_value(ha_value);
                call.perform();
              }
              else if (current_page_id_value == 5) {
                auto call = id(ha_3_pre_minute).make_call();
                call.set_value(ha_value);
                call.perform();
              }
              else if (current_page_id_value == 6) {
                auto call = id(ha_4_pre_minute).make_call();
                call.set_value(ha_value);
                call.perform();
              }
              ESP_LOGD("rotary_encoder_script", "%s setting ha_%i_pre_minute to %i", rotation.c_str(), current_page_id_value-2, ha_value);
            }
          }
          else if (current_page_id_value == 7) { //sleep timer pages
            int sleep_timer_duration_value = id(sleep_timer_duration).state;
            if (rotate_switch_single_value == 1) { //update sleep timer minutes
              if (clockwise) {
                sleep_timer_duration_value += 5;
                if (sleep_timer_duration_value > 180) {
                  sleep_timer_duration_value = 10;
                }
              }
              else {
                sleep_timer_duration_value -= 5;
                if (sleep_timer_duration_value < 10) {
                  sleep_timer_duration_value = 180;
                }
              }

              auto call = id(sleep_timer_duration).make_call();
              call.set_value(sleep_timer_duration_value);
              call.perform();

              ESP_LOGD("rotary_encoder_script", "%s setting sleep_timer_duration to %i", rotation.c_str(), sleep_timer_duration_value);
            }
          }
          else if (current_page_id_value == 8) { //Radio selector page
            auto size = id(alarm_stream_name).size();
            ESP_LOGD("rotary_encoder_script", "alarm_stream_name select has %d options", size);

            auto index = id(alarm_stream_name).active_index();
            if (index.has_value()) {
              ESP_LOGD("rotary_encoder_script", "alarm_stream_name option at index %d is active", index.value());

              int currentIndex = index.value();
              if (clockwise) {
                currentIndex += 1;
                if (currentIndex >= size) {
                  currentIndex = 0;
                }
              }
              else {
                currentIndex -= 1;
                if (currentIndex < 0) {
                  currentIndex = size -1;
                }
              }

              auto alarmStreamName = id(alarm_stream_name).make_call();
              alarmStreamName.set_index(currentIndex);
              alarmStreamName.perform();

              ESP_LOGD("rotary_encoder_script", "alarm_stream_name new selected index is %i", currentIndex);
            } else {
              ESP_LOGD("rotary_encoder_script", "alarm_stream_name no option is active");
            }
          }
          else if (current_page_id_value == 10) { //alarm contrast page
            if (id(time_sunrise)) {
              int screen_contrast_day_value = id(screen_contrast_day).state;
              if (clockwise == true) {
                screen_contrast_day_value += 5;
              }
              else {
                screen_contrast_day_value -= 5;
              }
              auto call = id(screen_contrast_day).make_call();
              call.set_value(screen_contrast_day_value);
              call.perform();
              ESP_LOGD("rotary_encoder_script", "%s setting screen_contrast_day to %i", rotation.c_str(), screen_contrast_day_value);
            }
            else {
              int screen_contrast_night_value = id(screen_contrast_night).state;
              if (clockwise == true) {
                screen_contrast_night_value += 5;
              }
              else {
                screen_contrast_night_value -= 5;
              }
              auto call = id(screen_contrast_night).make_call();
              call.set_value(screen_contrast_night_value);
              call.perform();
              ESP_LOGD("rotary_encoder_script", "%s setting screen_contrast_night to %i", rotation.c_str(), screen_contrast_night_value);
            }
            id(reset_page_script).execute();
          }
          else if (current_page_id_value == 11) { //restart page
            ESP_LOGD("rotary_encoder_script", "Start rotate_switch_single with %i", rotate_switch_single_value);
            if (rotate_switch_single_value == 0) {
              rotate_switch_single_value = 1;
            }
            else {
              rotate_switch_single_value = 0;
            }
            ESP_LOGD("rotary_encoder_script", "Update rotate_switch_single with %i", rotate_switch_single_value);
            id(rotate_switch_single) = rotate_switch_single_value;
            id(reset_page_script).execute();
          }
          else if (current_page_id_value == 12) { //alarm volume page
            int value = id(alarm_volume).state;
            if (clockwise == false) {
              value -=1;
              if (value < 0) {
                value = 0;
              }
            }
            else {
              value +=1;
              if (value > 100) {
                value = 100;
              }
            }

            auto call = id(alarm_volume).make_call();
            call.set_value(value);
            call.perform();
            id(reset_page_script).execute();
          }

          ESP_LOGD("rotary_encoder_script", "Page %i with rotation %s", current_page_id_value, rotation.c_str());
  - id: reset_page_script
    mode: restart
    then:
      - delay: 5000ms
      - script.execute:
          id: reset_page_script_no_timeout
  - id: reset_page_script_no_timeout
    mode: restart
    then:
      - display.page.show: !lambda
          id(rotate_switch_single) = 0;
          id(rotate_switch_double) = 0;
          ESP_LOGD("reset_page_script", "Reset page executed");
          return id(page1);
  - id: set_ha_0_trigger_time_script
    mode: restart
    then:
      - delay: 3000ms
      - script.execute:
          id: set_schedule_trigger_time_script
          index: 1
      - script.execute:
          id: set_schedule_trigger_time_script
          index: 2
      - script.execute:
          id: set_schedule_trigger_time_script
          index: 3
      - script.execute:
          id: set_schedule_trigger_time_script
          index: 4
  - id: set_ha_1_trigger_time_script
    mode: restart
    then:
      - delay: 3000ms
      - script.execute:
          id: set_schedule_trigger_time_script
          index: 1
  - id: set_ha_2_trigger_time_script
    mode: restart
    then:
      - delay: 3000ms
      - script.execute:
          id: set_schedule_trigger_time_script
          index: 2
  - id: set_ha_3_trigger_time_script
    mode: restart
    then:
      - delay: 3000ms
      - script.execute:
          id: set_schedule_trigger_time_script
          index: 3
  - id: set_ha_4_trigger_time_script
    mode: restart
    then:
      - delay: 3000ms
      - script.execute:
          id: set_schedule_trigger_time_script
          index: 4
  - id: set_schedule_trigger_time_script
    mode: queued
    parameters:
      index: int
    then:
      - wait_until:
          lambda: 'return (id(time_sync_done) == true);'
      - lambda: |-
          ESP_LOGD("set_schedule_trigger_time_script", "processing index %i", index);
          char str[20];
          time_t currentTimeForSchedule = id(ntp).now().timestamp;

          //get the midnight of today
          char currentHour[5];
          char currentMinute[5];
          char currentSecond[5];
          strftime(currentHour, sizeof(currentHour), "%H", localtime(&currentTimeForSchedule));
          strftime(currentMinute, sizeof(currentMinute), "%M", localtime(&currentTimeForSchedule));
          strftime(currentSecond, sizeof(currentSecond), "%S", localtime(&currentTimeForSchedule));
          int iCurrentHour = atoi(currentHour);
          int iCurrentMinute = atoi(currentMinute);
          int iCurrentSecond = atoi(currentSecond);
          currentTimeForSchedule -= iCurrentSecond; //second 0 of the current minute

          strftime(str, sizeof(str), "%Y-%m-%d %H:%M:%S", localtime(&currentTimeForSchedule));
          ESP_LOGD("set_schedule_trigger_time_script", "currentTimeForSchedule time %s", str);

          time_t currentTimeMidnight = currentTimeForSchedule;
          int secondsFromMidnight = (iCurrentHour * 60 * 60) + (iCurrentMinute * 60);
          currentTimeMidnight -= secondsFromMidnight;

          strftime(str, sizeof(str), "%Y-%m-%d %H:%M:%S", localtime(&currentTimeMidnight));
          ESP_LOGD("set_schedule_trigger_time_script", "currentTimeMidnight time %s. seconds from midnight is %i", str, secondsFromMidnight);

          //calculate the time the alarm would go off
          int alarmHour = id(alarm_hour).state;
          int alarmMinute = id(alarm_minute).state;
          int alarmTime = (60 * 60 * alarmHour) + (60 * alarmMinute);
          ESP_LOGD("set_schedule_trigger_time_script", "alarmHour %i alarmMinute %i alarmTime %i", alarmHour, alarmMinute, alarmTime);
          time_t newSchedule = currentTimeMidnight + alarmTime;

          //substract the ha_pre_minute to get the time for the required schedule
          if (index == 1) {
            int ha1Seconds = (60 * id(ha_1_pre_minute).state);
            newSchedule += ha1Seconds;
            ESP_LOGD("set_schedule_trigger_time_script", "HA 1 seconds to add %i", ha1Seconds);
          }
          else if (index == 2) {
            int ha2Seconds = (60 * id(ha_2_pre_minute).state);
            newSchedule += ha2Seconds;
            ESP_LOGD("set_schedule_trigger_time_script", "HA 2 seconds to add %i", ha2Seconds);
          }
          else if (index == 3) {
            int ha3Seconds = (60 * id(ha_3_pre_minute).state);
            newSchedule += ha3Seconds;
            ESP_LOGD("set_schedule_trigger_time_script", "HA 3 seconds to add %i", ha3Seconds);
          }
          else if (index == 4) {
            int ha4Seconds = (60 * id(ha_4_pre_minute).state);
            newSchedule += ha4Seconds;
            ESP_LOGD("set_schedule_trigger_time_script", "HA 4 seconds to add %i", ha4Seconds);
          }
          else if (index == 5) { //sleep timer
            int sleepTimerDuration = id(sleep_timer_duration).state;
            ESP_LOGD("set_schedule_trigger_time_script", "sleepTimerDuration time %i", sleepTimerDuration);
            newSchedule = currentTimeForSchedule + (sleepTimerDuration * 60);
          }
          else if (index == 6) { //snooze
            int snoozeDuration = id(snooze_duration).state;
            ESP_LOGD("set_schedule_trigger_time_script", "snoozeDuration time %i", snoozeDuration);
            newSchedule = currentTimeForSchedule + (snoozeDuration * 60);
          }

          strftime(str, sizeof(str), "%Y-%m-%d %H:%M:%S", localtime(&newSchedule));
          ESP_LOGD("set_schedule_trigger_time_script", "newSchedule time %s", str);

          //set the schedule time
          char scheduleHour[5];
          char scheduleMinute[5];
          strftime(scheduleHour, sizeof(scheduleHour), "%H", localtime(&newSchedule));
          strftime(scheduleMinute, sizeof(scheduleMinute), "%M", localtime(&newSchedule));

          //string for display time
          char strForDisplay[6];
          strftime(strForDisplay, sizeof(strForDisplay), "%H:%M", localtime(&newSchedule));

          //current time as timestamp
          int currentTimestamp = currentTimeForSchedule;
          int iNewScheduleTimeStamp = newSchedule;

          //assign the new schedule
          if (index == 1) {
            auto haMinuteNumber1 = id(ha_1_minute).make_call();
            haMinuteNumber1.set_value(atoi(scheduleMinute));
            haMinuteNumber1.perform();

            auto haHourNumber1 = id(ha_1_hour).make_call();
            haHourNumber1.set_value(atoi(scheduleHour));
            haHourNumber1.perform();
            id(ha_1_time).publish_state(strForDisplay);
          }
          else if (index == 2) {
            auto haMinuteNumber2 = id(ha_2_minute).make_call();
            haMinuteNumber2.set_value(atoi(scheduleMinute));
            haMinuteNumber2.perform();

            auto haHourNumber2 = id(ha_2_hour).make_call();
            haHourNumber2.set_value(atoi(scheduleHour));
            haHourNumber2.perform();
            id(ha_2_time).publish_state(strForDisplay);
          }
          else if (index == 3) {
            auto haMinuteNumber3 = id(ha_3_minute).make_call();
            haMinuteNumber3.set_value(atoi(scheduleMinute));
            haMinuteNumber3.perform();

            auto haHourNumber3 = id(ha_3_hour).make_call();
            haHourNumber3.set_value(atoi(scheduleHour));
            haHourNumber3.perform();
            id(ha_3_time).publish_state(strForDisplay);
          }
          else if (index == 4) {
            auto haMinuteNumber4 = id(ha_4_minute).make_call();
            haMinuteNumber4.set_value(atoi(scheduleMinute));
            haMinuteNumber4.perform();

            auto haHourNumber4 = id(ha_4_hour).make_call();
            haHourNumber4.set_value(atoi(scheduleHour));
            haHourNumber4.perform();
            id(ha_4_time).publish_state(strForDisplay);
          }
          else if (index == 5) {
            int sleepTimerTimestamp = id(sleep_timer_timestamp).state;
            if (currentTimestamp > sleepTimerTimestamp) {
              ESP_LOGD("set_schedule_trigger_time_script", "Updating sleep timer time");

              auto sleepTimerTimestampNumber = id(sleep_timer_timestamp).make_call();
              sleepTimerTimestampNumber.set_value(iNewScheduleTimeStamp);
              sleepTimerTimestampNumber.perform();
            }
            else {
              ESP_LOGD("set_schedule_trigger_time_script", "Not updating sleep timer time, current time is before sleeptimer");
            }
          }
          else if (index == 6) {
            int snoozeTimestamp = id(snooze_timestamp);
            if (currentTimestamp > snoozeTimestamp) {
              ESP_LOGD("set_schedule_trigger_time_script", "Updating snooze time with %i", iNewScheduleTimeStamp);
              id(set_snooze_timestamp).execute(iNewScheduleTimeStamp);
            }
            else {
              ESP_LOGD("set_schedule_trigger_time_script", "Not updating snooze time, current time is before snooze");
            }
          }
  - id: check_alarms
    mode: restart
    then:
      - lambda: |-
          time_t currentTimeForAlarm = id(ntp).now().timestamp;

          //get time to calculate with
          char cCurrentHour[5];
          char cCurrentMinute[5];
          char cCurrentSecond[5];
          strftime(cCurrentHour, sizeof(cCurrentHour), "%H", localtime(&currentTimeForAlarm));
          strftime(cCurrentMinute, sizeof(cCurrentMinute), "%M", localtime(&currentTimeForAlarm));
          strftime(cCurrentSecond, sizeof(cCurrentSecond), "%S", localtime(&currentTimeForAlarm));
          int iCurrentHour = atoi(cCurrentHour);
          int iCurrentMinute = atoi(cCurrentMinute);
          int iCurrentSecond = atoi(cCurrentSecond);
          int iAlarmHours = id(alarm_hour).state;
          int iAlarmMinutes = id(alarm_minute).state;

          //get the timestamp
          int currentTimeForAlarmTimeStamp = currentTimeForAlarm;

          if (!id(alarm_on).state && id(alarm_enabled).state) {
            //get the midnight of today
            time_t currentTimeForAlarmMidnight = currentTimeForAlarm; //second 0 of the current minute
            int secondsFromMidnight = (iCurrentHour * 60 * 60) + (iCurrentMinute * 60) + iCurrentSecond;
            currentTimeForAlarmMidnight -= secondsFromMidnight;
            int iCurrentTimeForAlarmMidnight = currentTimeForAlarmMidnight;
            int alarmTimeStamp = iCurrentTimeForAlarmMidnight + (iAlarmHours * 60  * 60) + (iAlarmMinutes * 60);
            int alarmOffTimeStamp = id(alarm_last_off);
            if (alarmTimeStamp <= currentTimeForAlarmTimeStamp) { //alarm time has passed
              if (alarmOffTimeStamp <= alarmTimeStamp) { //alarm time is after the last time alarm was set to off
                id(alarm_on).turn_on();
                ESP_LOGD("check_alarms", "alarm on");
              }
            }
          }

          if (iCurrentHour == id(ha_1_hour).state && iCurrentMinute == id(ha_1_minute).state && id(ha_1_enabled).state) {
            if (id(alarm_enabled).state && id(ha_1_alarmed).state || !id(ha_1_alarmed).state) {
              id(ha_1_on).turn_on();
              ESP_LOGD("check_alarms", "ha 1 on");
            }
          }
          if (iCurrentHour == id(ha_2_hour).state && iCurrentMinute == id(ha_2_minute).state && id(ha_2_enabled).state) {
            if (id(alarm_enabled).state && id(ha_2_alarmed).state || !id(ha_2_alarmed).state) {
              id(ha_2_on).turn_on();
              ESP_LOGD("check_alarms", "ha 2 on");
            }
          }
          if (iCurrentHour == id(ha_3_hour).state && iCurrentMinute == id(ha_3_minute).state && id(ha_3_enabled).state) {
            if (id(alarm_enabled).state && id(ha_3_alarmed).state || !id(ha_3_alarmed).state) {
              id(ha_3_on).turn_on();
              ESP_LOGD("check_alarms", "ha 3 on");
            }
          }
          if (iCurrentHour == id(ha_4_hour).state && iCurrentMinute == id(ha_4_minute).state && id(ha_4_enabled).state) {
            if (id(alarm_enabled).state && id(ha_4_alarmed).state || !id(ha_4_alarmed).state) {
              id(ha_4_on).turn_on();
              ESP_LOGD("check_alarms", "ha 4 on");
            }
          }
          if (id(snooze_on).state) {
            int snoozeTimestamp = id(snooze_timestamp);
            //ESP_LOGD("check_alarms", "current %i snooze %i", currentTimeForAlarmTimeStamp, snoozeTimestamp);
            if (currentTimeForAlarmTimeStamp >= snoozeTimestamp) {
              id(snooze_on).turn_off();
              ESP_LOGD("check_alarms", "snooze off");
              if (id(alarm_enabled).state && !id(alarm_on).state) {
                id(alarm_on).turn_on();
                ESP_LOGD("check_alarms", "snooze alarm on");
              }
            }
          }
          if (id(sleep_timer_on).state) {
            int sleepTimerTimestamp = id(sleep_timer_timestamp).state;
            //ESP_LOGD("check_alarms", "current %i sleeptimer %i", currentTimeForAlarmTimeStamp, sleepTimerTimestamp);
            if (currentTimeForAlarmTimeStamp >= sleepTimerTimestamp) {
              id(sleep_timer_on).turn_off();
              ESP_LOGD("check_alarms", "Sleep timer disabled");
            }
          }
  - id: set_alarm_last_off
    then:
      - lambda:
          id(alarm_last_off) = id(ntp).now().timestamp;
          ESP_LOGD("set_alarm_last_off", "alarm_last_off %i", id(alarm_last_off));
  - id: set_snooze_timestamp
    parameters:
      timestamp: int
    then:
      - lambda:
          id(snooze_timestamp) = timestamp;
          ESP_LOGD("set_alarm_last_off", "alarm_last_off %i", id(snooze_timestamp));
      - if:
          condition:
            - lambda: 'return { (id(time_sync_done) == true) };'
          then:
            - component.update: snooze_time