esphome:
  on_boot:
    - priority: 800
      then:
        - script.execute: time_sync_wait

logger:
  on_message:
    level: ERROR
    then:
      - lambda: |-
          //catch error thrown by speaker_media_player
          if (tag == "speaker_media_player" && id(media_player_alarm).state == 2 && (id(alarm_on).state || id(music_on).state)) { //MEDIA_PLAYER_STATE_NONE = 0 , MEDIA_PLAYER_STATE_IDLE = 1 , MEDIA_PLAYER_STATE_PLAYING = 2 , MEDIA_PLAYER_STATE_PAUSED = 3 ,  MEDIA_PLAYER_STATE_ANNOUNCING = 4
            id(media_player_stopped) = id(media_player_stopped) + 1;
            int maxCounter = 4;
            if (id(media_player_stopped) > maxCounter) {
              //id(debug_logger).publish_state("Level: " + to_string(level) + ". Tag: " + tag + ". Message:" + message);
              if (id(alarm_on).state) {
                id(alarm_on_local).turn_on();
              }
              else if (id(music_on).state) {
                id(music_on).turn_off(); //switching music off, it does not work
              }
            }
          }
          else if (tag == "speaker_media_player" && id(media_player_alarm).state == 4 && id(alarm_on).state) { //error on announcement
            //id(debug_logger).publish_state("announcing Level: " + to_string(level) + ". Tag: " + tag + ". Message:" + message);
          }

i2c:
  sda: ${i2c_sda}
  scl: ${i2c_scl}
  frequency: 800kHz

i2s_audio:
  - id: i2s_out
    i2s_lrclk_pin: ${i2s_lrclk_pin}
    i2s_bclk_pin: ${i2s_bclk_pin}

speaker:
  - id: speaker_id
    platform: i2s_audio
    dac_type: external
    i2s_dout_pin: ${i2s_dout_pin}
    sample_rate: 48000
  - id: mixer_speaker_id
    platform: mixer
    output_speaker: speaker_id
    source_speakers:
      - id: announcement_spk_mixer_input
      - id: media_spk_mixer_input
  - id: media_spk_resampling_input
    platform: resampler
    output_speaker: media_spk_mixer_input
  - id: announcement_spk_resampling_input
    platform: resampler
    output_speaker: announcement_spk_mixer_input

media_player:
  - id: media_player_alarm
    platform: speaker
    name: Media player alarm
    media_pipeline:
        speaker: media_spk_resampling_input
        num_channels: 1
    announcement_pipeline:
        speaker: announcement_spk_resampling_input
        num_channels: 1
    on_announcement:
      - mixer_speaker.apply_ducking:
          id: media_spk_mixer_input
          decibel_reduction: 20
          duration: 0.0s
      - wait_until:
          not:
            media_player.is_announcing:
      - mixer_speaker.apply_ducking:
          id: media_spk_mixer_input
          decibel_reduction: 0
          duration: 1.0s
    files:
      - id: alarm_sound
        file: ${alarm_file}
    on_play:
      - logger.log: "Playback started!"
    on_pause:
      - logger.log: "Playback paused!"
    on_idle:
      - logger.log: "Playback finished!"

font:
  - id: robotomedium40
    file: fonts/Roboto-Medium.ttf
    size: 40
    <<: &extras
      extras:
        - file: "fonts/materialdesignicons-webfont.ttf"
          glyphs: [ #https://github.com/juliettef/IconFontCppHeaders/blob/main/IconsMaterialDesignIcons.cs
            "\U000F091F", # WifiStrength1
            "\U000F0922", # WifiStrength2
            "\U000F0925", # WifiStrength3
            "\U000F0928", # WifiStrength4
            "\U000F092F", # WifiStrengthOutline
            "\U000F092E", # WifiStrengthOffOutline
            "\U000F0020", # Alarm
            "\U000F0E71", # AlarmNote
            "\U000F0023", # AlarmOff
            "\U000F0021", # AlarmCheck
            "\U000F068E", # AlarmSnooze;
            "\U000F1ADD", # TimerMusicOutline
            "\U000F07D0", # HomeAssistant
            "\U000F15D0", # HomeAlertOutline
            "\U000F1A47", # HomeOffOutline
            "\U000F0197", # ContrastCircle
            "\U000F0157", # CloseBox
            "\U000F0158", # CloseBoxOutline
            "\U000F0C52", # CheckboxOutline
            "\U000F0132", # CheckboxMarked
            "\U000F0131", # CheckboxBlankOutline
            "\U000F09DF", # CircleSmall
            "\U000F0764", # Square
            "\U000F0A13", # SquareMedium
            "\U000F0763", # SquareOutline
            "\U000F057E", # VolumeHigh
            "\U000F0387", # MusicNote
          ]
  - id: robotomedium51
    file: fonts/Roboto-Medium.ttf
    size: 51
    <<: *extras
  - id: robotomedium30
    file: fonts/Roboto-Medium.ttf
    size: 30
    <<: *extras
  - id: robotomedium20
    file: fonts/Roboto-Medium.ttf
    size: 20
    <<: *extras
  - id: robotomedium15
    file: fonts/Roboto-Medium.ttf
    size: 15
    <<: *extras
  - id: robotothin51
    file: fonts/roboto-thin.ttf
    size: 51
    <<: *extras
  - id: robotothin20
    file: fonts/roboto-thin.ttf
    size: 20
    <<: *extras
  - id: robotothin15
    file: fonts/roboto-thin.ttf
    size: 15
    <<: *extras

globals:
  - id: time_sync_done
    type: bool
    initial_value: "false"
  - id: current_page_id
    type: int
    initial_value: "1"
  - id: rotate_switch_single
    type: int
    initial_value: "0"
  - id: rotate_switch_double
    type: int
    initial_value: "0"
  - id: api_connected
    type: bool
    restore_value: no
    initial_value: 'false'
  - id: alarm_last_off
    type: int
    restore_value: yes
    initial_value: '0'
  - id: snooze_timestamp
    type: int
    restore_value: yes
    initial_value: '0'
  - id: media_player_stopped
    type: int
    initial_value: '0'
  - id: media_player_watchdog_count
    type: int
    initial_value: '0'
  - id: contrast_current
    type: float
    initial_value: '1.0'
  - id: contrast_target
    type: float
    initial_value: '1.0'    

interval:
  - interval: 10s
    then:
      #api connection state
      - if:
          condition:
            api.connected:
          then:
            - if:
                condition:
                  - lambda: 'return { (id(api_connected) != true) };'
                then:
                  - lambda: |-
                      ESP_LOGD("interval", "Api connected. Setting api_connected to true");
                      id(api_connected) = true;
          else:
             - if:
                condition:
                  not:
                    api.connected:
                then:
                  - if:
                      condition:
                        - lambda: 'return { (id(api_connected) == true) };'
                      then:
                        - lambda: |-
                            ESP_LOGD("interval", "Api disconnected. Setting api_connected to false");
                            id(api_connected) = false;

time:
  - id: ntp
    platform: sntp
    on_time:
      - seconds: /5
        minutes: "*"
        then:
          - script.execute: media_player_watchdog
      - seconds: 0,30
        minutes: "*"
        then:
          - script.execute: check_alarms
          - if:
              condition:
                - switch.is_on: night_mode_automatically
              then:
                - if:
                    condition:
                        - sun.is_above_horizon:
                    then:
                      - switch.turn_off: night_mode
                    else:
                      - switch.turn_on: night_mode

sun:
  latitude: ${sun_latitude}
  longitude: ${sun_longitude}

number:
  - name: Screen contrast day
    platform: template
    optimistic: true
    id: screen_contrast_day
    initial_value: 0
    restore_value: true
    min_value: 0
    max_value: 100
    step: 1
    mode: slider
  - name: Screen contrast night
    platform: template
    optimistic: true
    id: screen_contrast_night
    initial_value: 0
    restore_value: true
    min_value: 0
    max_value: 100
    step: 1
    mode: slider
  - name: "Alarm hour"
    id: alarm_hour
    platform: template
    entity_category: config
    optimistic: true
    restore_value: true
    initial_value: 0
    min_value: 0
    max_value: 23
    step: 1
    mode: slider
    on_value:
      - script.execute:
          id: set_ha_0_trigger_time_script
      - script.execute:
          id: set_alarm_last_off
  - name: "Alarm minute"
    platform: template
    id: alarm_minute
    entity_category: config
    optimistic: true
    restore_value: true
    initial_value: 0
    min_value: 0
    max_value: 59
    step: 1
    mode: slider
    on_value:
      - script.execute:
          id: set_ha_0_trigger_time_script
      - script.execute:
          id: set_alarm_last_off
  - name: "Snooze duration"
    platform: template
    id: snooze_duration
    entity_category: config
    optimistic: true
    restore_value: true
    initial_value: 9
    min_value: 1
    max_value: 99
    step: 1
    mode: slider
  - name: "Home Assistant 1 pre minute"
    platform: template
    id: ha_1_pre_minute
    entity_category: config
    optimistic: true
    restore_value: true
    initial_value: 0
    min_value: -99
    max_value: 99
    step: 1
    mode: slider
    on_value:
      - script.execute:
          id: set_ha_1_trigger_time_script
  - name: "Home Assistant 1 minute"
    platform: template
    id: ha_1_minute
    entity_category: config
    optimistic: true
    restore_value: true
    initial_value: 0
    min_value: 0
    max_value: 59
    step: 1
    internal: true
  - name: "Home Assistant 1 hour"
    platform: template
    id: ha_1_hour
    entity_category: config
    optimistic: true
    restore_value: true
    initial_value: 0
    min_value: 0
    max_value: 23
    step: 1
    internal: true
  - name: "Home Assistant 2 pre minute"
    platform: template
    id: ha_2_pre_minute
    entity_category: config
    optimistic: true
    restore_value: true
    initial_value: 0
    min_value: -99
    max_value: 99
    step: 1
    mode: slider
    on_value:
      - script.execute:
          id: set_ha_2_trigger_time_script
  - name: "Home Assistant 2 minute"
    platform: template
    id: ha_2_minute
    entity_category: config
    optimistic: true
    restore_value: true
    initial_value: 0
    min_value: 0
    max_value: 59
    step: 1
    internal: true
  - name: "Home Assistant 2 hour"
    platform: template
    id: ha_2_hour
    entity_category: config
    optimistic: true
    restore_value: true
    initial_value: 0
    min_value: 0
    max_value: 23
    step: 1
    internal: true
  - name: "Home Assistant 3 pre minute"
    platform: template
    id: ha_3_pre_minute
    entity_category: config
    optimistic: true
    restore_value: true
    initial_value: 0
    min_value: -99
    max_value: 99
    step: 1
    mode: slider
    on_value:
      - script.execute:
          id: set_ha_3_trigger_time_script
  - name: "Home Assistant 3 minute"
    platform: template
    id: ha_3_minute
    entity_category: config
    optimistic: true
    restore_value: true
    initial_value: 0
    min_value: 0
    max_value: 59
    step: 1
    internal: true
  - name: "Home Assistant 3 hour"
    platform: template
    id: ha_3_hour
    entity_category: config
    optimistic: true
    restore_value: true
    initial_value: 0
    min_value: 0
    max_value: 23
    step: 1
    internal: true
  - name: "Home Assistant 4 pre minute"
    platform: template
    id: ha_4_pre_minute
    entity_category: config
    optimistic: true
    restore_value: true
    initial_value: 0
    min_value: -99
    max_value: 99
    step: 1
    mode: slider
    on_value:
      - script.execute:
          id: set_ha_4_trigger_time_script
  - name: "Home Assistant 4 minute"
    platform: template
    id: ha_4_minute
    entity_category: config
    optimistic: true
    restore_value: true
    initial_value: 0
    min_value: 0
    max_value: 59
    step: 1
    internal: true
  - name: "Home Assistant 4 hour"
    platform: template
    id: ha_4_hour
    entity_category: config
    optimistic: true
    restore_value: true
    initial_value: 0
    min_value: 0
    max_value: 23
    step: 1
    internal: true
  - name: "Alarm volume"
    platform: template
    id: alarm_volume
    entity_category: config
    optimistic: true
    restore_value: true
    initial_value: 50
    min_value: 0
    max_value: 100
    step: 1
    mode: slider
    on_value:
      - media_player.volume_set: !lambda "return (x/100);"
  - name: "Sleep timer duration"
    platform: template
    id: sleep_timer_duration
    entity_category: config
    optimistic: true
    restore_value: true
    initial_value: 10
    min_value: 10
    max_value: 180
    step: 5
    mode: slider
  - name: "Sleep timer timestamp"
    platform: template
    id: sleep_timer_timestamp
    entity_category: config
    optimistic: true
    restore_value: true
    initial_value: 0
    min_value: 0
    max_value: 9223372036854775807
    on_value:
      then:
        - if:
            condition:
              lambda: 'return (id(time_sync_done) == true);'
            then:
              - lambda:
                  time_t sleepTimerTimestampX = x;
                  char sleepTimer[6];
                  strftime(sleepTimer, sizeof(sleepTimer), "%H:%M", localtime(&sleepTimerTimestampX));
                  id(sleep_timer_time).publish_state(sleepTimer);
    step: 1
    internal: true
  - name: "Alarm volume increase"
    platform: template
    id: alarm_volume_increase
    entity_category: config
    optimistic: true
    restore_value: true
    initial_value: 0
    min_value: 0
    max_value: 100
    step: 1
    mode: slider
  - name: "Alarm volume increase duration"
    platform: template
    id: alarm_volume_increase_duration
    entity_category: config
    optimistic: true
    restore_value: true
    initial_value: 0
    min_value: 0
    max_value: 300
    step: 30
    mode: slider

text_sensor:
  - name: "Sleep timer time"
    platform: template
    id: sleep_timer_time
    lambda: |-
      time_t sleepTimerTimestampTS = id(sleep_timer_timestamp).state;
      char sleepTSDisplay[6];
      strftime(sleepTSDisplay, sizeof(sleepTSDisplay), "%H:%M", localtime(&sleepTimerTimestampTS));
      return esphome::str_sprintf(sleepTSDisplay);
    update_interval: 60s
  - name: "Snooze time"
    platform: template
    id: snooze_time
    lambda: |-
      time_t snoozeTimestampTS = id(snooze_timestamp);
      char snoozeTSDisplay[6];
      strftime(snoozeTSDisplay, sizeof(snoozeTSDisplay), "%H:%M", localtime(&snoozeTimestampTS));
      return esphome::str_sprintf(snoozeTSDisplay);
    update_interval: 60s
  - name: "Home Assistant 1 time"
    platform: template
    id: ha_1_time
  - name: "Home Assistant 2 time"
    platform: template
    id: ha_2_time
  - name: "Home Assistant 3 time"
    platform: template
    id: ha_3_time
  - name: "Home Assistant 4 time"
    platform: template
    id: ha_4_time
  # - name: "Debug logger"
  #   platform: template
  #   id: debug_logger
  #   lambda: |-
  #     return {" "};
  #   update_interval: 60s
  - name: "Alarm on timestamp"
    platform: template
    id: alarm_on_timestamp
    internal: true

sensor:
  - name: "WiFi Signal Sensor"
    platform: wifi_signal
    id: wifi_signal_db
    update_interval: 60s
  - name: "WiFi Signal Percent"
    platform: copy # Reports the WiFi signal strength in %
    source_id: wifi_signal_db
    id: wifi_signal_percent
    filters:
      - lambda: return min(max(2 * (x + 100.0), 0.0), 100.0);
    unit_of_measurement: "Signal %"
    entity_category: "diagnostic"
    device_class: ""
  - name: "Rotary Encoder"
    platform: rotary_encoder
    pin_a:
      number: ${pin_a}
      mode: INPUT_PULLUP
    pin_b:
      number: ${pin_b}
      mode: INPUT_PULLUP
    on_anticlockwise:
      then:
        - if:
            condition:
              and:
                - switch.is_on: display_on_off_automatically
                - switch.is_off: display_on
            then:
              - switch.turn_on: display_on
              - script.execute:
                  id: display_off_script
            else:
              - if:
                  condition:
                    lambda: |-
                      if (id(current_page_id) == 1 && (id(alarm_on).state || id(music_on).state)) {
                        ESP_LOGD("rotary_encoder", "alarm is on, show volume");
                        return true;
                      }
                      return false;
                  then:
                    - display.page.show: page12
                    - script.execute:
                        id: reset_page_script
                  else: #browse all pages
                    - if:
                        condition:
                          lambda: |-
                            if (id(rotate_switch_single) == 0 && id(rotate_switch_double) == 0 && id(current_page_id) < 9) {
                              ESP_LOGD("rotary_encoder", "anticlockwise");
                              return true;
                            }
                            return false;
                        then:
                          - if: #dont show special pages
                              condition:
                                display.is_displaying_page:
                                  id: alarmdisplay
                                  page_id: page1
                              then:
                                - display.page.show: page8
                              else:
                                - display.page.show_previous: alarmdisplay
                          - script.execute:
                              id: reset_page_script
                        else: #edit items on page
                          - script.execute:
                              id: rotary_encoder_script
                              clockwise: false
    on_clockwise:
      then:
        - if:
            condition:
              and:
                - switch.is_on: display_on_off_automatically
                - switch.is_off: display_on
            then:
              - switch.turn_on: display_on
              - script.execute:
                  id: display_off_script
            else:
              - if:
                  condition:
                    lambda: |-
                      if (id(current_page_id) == 1 && (id(alarm_on).state || id(music_on).state)) {
                        ESP_LOGD("rotary_encoder", "alarm is on, show volume");
                        return true;
                      }
                      return false;
                  then:
                    - display.page.show: page12
                    - script.execute:
                        id: reset_page_script
                  else: #browse all pages
                    - if:
                        condition:
                          lambda: |-
                            if (id(rotate_switch_single) == 0 && id(rotate_switch_double) == 0 && id(current_page_id) < 9) {
                              ESP_LOGD("rotary_encoder", "clockwise");
                              return true;
                            }
                            return false;
                        then:
                          - if: #dont show special pages
                              condition:
                                display.is_displaying_page:
                                  id: alarmdisplay
                                  page_id: page8
                              then:
                                - display.page.show: page1
                              else:
                                - display.page.show_next: alarmdisplay
                          - script.execute:
                              id: reset_page_script
                        else: #edit items on page
                          - script.execute:
                              id: rotary_encoder_script
                              clockwise: true

binary_sensor:
  - name: "Alarm off"
    platform: gpio
    pin:
      number: ${alarm_off_button_pin}
      mode:
        input: true
        pullup: true
      inverted: true
    on_multi_click:
      - timing: #single click
        - ON for at most ${alarm_off_button_single_click_time}
        - OFF for at least 0.5s
        then:
          - script.execute:
              id: display_off_script
          - lambda: |-
              if (id(display_on_off_automatically).state && !id(display_on).state) {
                id(display_on).turn_on();
              } else {
                if (id(alarm_on).state && !id(snooze_on).state) {
                  id(snooze_on).turn_on();
                }
                else if (id(snooze_on).state) {
                  id(snooze_on).turn_off();
                }
                else if (id(sleep_timer_on).state) {
                  id(sleep_timer_on).turn_off();
                  id(music_on).turn_off();
                }
                else if (!id(alarm_on).state && id(sleep_timer_enabled).state) {
                  id(music_on).turn_on();
                  id(sleep_timer_on).turn_on();
                }
                else if (!id(music_on).state) {
                  id(music_on).turn_on();
                }
                else if (id(music_on).state) {
                  id(music_on).turn_off();
                }
              }

  - name: "Rotary Button"
    platform: gpio
    pin:
      number: ${rotary_button_pin}
      mode: INPUT_PULLUP
      inverted: true
    id: magic_button_board_button
    on_release:
      - logger.log: "Released"
    on_multi_click:
      - timing: #long click
        - ON for at least 2s
        - OFF for at least 0.5s
        then:
          - logger.log: "Long Click"
          - if:
              condition:
                and:
                  - switch.is_on: display_on_off_automatically
                  - switch.is_off: display_on
              then:
                - switch.turn_on: display_on
                - script.execute:
                    id: display_off_script
              else:
                - if:
                    condition:
                      display.is_displaying_page: page1
                    then:
                      - display.page.show: page11
                      - script.execute:
                          id: reset_page_script
      - timing: #triple click
        - ON for at most 0.5s
        - OFF for at most 0.5s
        - ON for at most 0.5s
        - OFF for at most 0.5s
        - ON for at most 0.5s
        - OFF for at least 0.5s
        then:
          - logger.log: "Triple Click"
          - if:
              condition:
                and:
                  - switch.is_on: display_on_off_automatically
                  - switch.is_off: display_on
              then:
                - switch.turn_on: display_on
                - script.execute:
                    id: display_off_script
              else:
                - if:
                    condition:
                      display.is_displaying_page: page1
                    then:
                      - display.page.show: page12
                      - script.execute:
                          id: reset_page_script
                - if:
                    condition:
                      display.is_displaying_page: page3
                    then:
                      - switch.toggle: ha_1_on
                      - script.execute:
                          id: reset_page_script_no_timeout
                - if:
                    condition:
                      display.is_displaying_page: page4
                    then:
                      - switch.toggle: ha_2_on
                      - script.execute:
                          id: reset_page_script_no_timeout
                - if:
                    condition:
                      display.is_displaying_page: page5
                    then:
                      - switch.toggle: ha_3_on
                      - script.execute:
                          id: reset_page_script_no_timeout
                - if:
                    condition:
                      display.is_displaying_page: page6
                    then:
                      - switch.toggle: ha_4_on
                      - script.execute:
                          id: reset_page_script_no_timeout
      - timing: #double click
        - ON for at most 0.5s
        - OFF for at most 0.5s
        - ON for at most 0.5s
        - OFF for at least 0.5s
        then:
          - logger.log: "Double Click"
          - if:
              condition:
                and:
                  - switch.is_on: display_on_off_automatically
                  - switch.is_off: display_on
              then:
                - switch.turn_on: display_on
                - script.execute:
                    id: display_off_script
              else:
                - if:
                    condition:
                      display.is_displaying_page: page1
                    then:
                      - display.page.show: page10
                      - script.execute:
                          id: reset_page_script
                - if:
                    condition:
                      display.is_displaying_page: page2
                    then:
                      - switch.toggle: alarm_enabled
                - if:
                    condition:
                      or:
                        - display.is_displaying_page: page3
                        - display.is_displaying_page: page4
                        - display.is_displaying_page: page5
                        - display.is_displaying_page: page6
                    then:
                      - lambda: |-
                          auto haEnabled = id(ha_1_enabled);
                          auto haAlarmed = id(ha_1_alarmed);
                          int current_page_value = id(current_page_id);
                          if (current_page_value == 4) {
                            haEnabled = id(ha_2_enabled);
                            haAlarmed = id(ha_2_alarmed);
                          }
                          else if (current_page_value == 5) {
                            haEnabled = id(ha_3_enabled);
                            haAlarmed = id(ha_3_alarmed);
                          }
                          else if (current_page_value == 6) {
                            haEnabled = id(ha_4_enabled);
                            haAlarmed = id(ha_4_alarmed);
                          }

                          if (haEnabled->state && haAlarmed->state) {
                            haEnabled->turn_off();
                            haAlarmed->turn_off();
                          }
                          else if (!haEnabled->state && haAlarmed->state) {
                            haAlarmed->turn_off();
                          }
                          else if (!haEnabled->state && !haAlarmed->state) {
                            haEnabled->turn_on();
                          }
                          else if (haEnabled->state && !haAlarmed->state) {
                            haAlarmed->turn_on();
                          }
                          id(reset_page_script).execute();
                - if:
                    condition:
                      display.is_displaying_page: page7
                    then:
                      - switch.toggle: sleep_timer_enabled
      - timing: #single click
        - ON for at most 0.5s
        - OFF for at least 0.5s
        then:
          - logger.log: "Single Click"
          - if:
              condition:
                and:
                  - switch.is_on: display_on_off_automatically
                  - switch.is_off: display_on
              then:
                - switch.turn_on: display_on
                - script.execute:
                    id: display_off_script
              else:
                - lambda: |-
                    int current_page_value = id(current_page_id);
                    if (current_page_value == 1) { //clock page
                      if (id(alarm_enabled).state) {
                        id(alarm_enabled).turn_off();
                      }
                      else {
                        id(alarm_enabled).turn_on();
                      }
                    }
                    else if (current_page_value == 2) { //alarm clock page
                      int value = id(rotate_switch_single);
                      value += 1;
                      if (value > 2) {
                        value = 0;
                      }
                      id(rotate_switch_single) = value;
                      if (value == 0) { //not in edit mode, start reset
                        id(reset_page_script).execute();
                      }
                      else {
                        id(reset_page_script).stop();
                      }
                    }
                    else if (current_page_value == 3 || current_page_value == 4 || current_page_value == 5 || current_page_value == 6) { //ha minute page
                      int value = id(rotate_switch_single);
                      value += 1;
                      if (value > 1) {
                        value = 0;
                      }
                      id(rotate_switch_single) = value;
                      if (value == 0) { //not in edit mode, start reset
                        id(reset_page_script).execute();
                      }
                      else {
                        id(reset_page_script).stop();
                      }
                    }
                    else if (current_page_value == 7) { //sleep timer
                      int value = id(rotate_switch_single);
                      value += 1;
                      if (value > 1) {
                        value = 0;
                      }
                      id(rotate_switch_single) = value;
                      if (value == 0) { //not in edit mode, start reset
                        id(reset_page_script).execute();
                      }
                      else {
                        id(reset_page_script).stop();
                      }
                    }
                    else if (current_page_value == 8) { //radio selector
                      int value = id(rotate_switch_single);
                      value += 1;
                      if (value > 1) {
                        value = 0;
                        id(music_on).turn_off();
                      }
                      else {
                        id(music_on).turn_on();
                      }
                      id(rotate_switch_single) = value;
                      if (value == 0) { //not in edit mode, start reset
                        id(reset_page_script).execute();
                      }
                      else {
                        id(reset_page_script).stop();
                      }
                    }
                    else if (current_page_value == 10 || current_page_value == 12) { //contrast\volume page
                      id(reset_page_script_no_timeout).execute();
                    }
                    else if (current_page_value == 11) { //restart page
                      if (id(rotate_switch_single) == 1) {
                        id(clock_restart_switch).turn_on();
                      }
                      else {
                        id(reset_page_script_no_timeout).execute();
                      }
                    }
                    else if (current_page_value == 12) { //sleep timer page
                      id(reset_page_script_no_timeout).execute();
                    }

select:
  - name: Alarm stream url
    platform: template
    id: alarm_stream_url
    optimistic: true
    restore_value: true
    set_action:
      - media_player.play_media:
          id: media_player_alarm
          media_url: !lambda 'return x.c_str();'
    internal: true
  - name: Alarm stream name
    platform: template
    id: alarm_stream_name
    optimistic: true
    restore_value: true
    set_action:
      - lambda: |-
          ESP_LOGD("alarm_stream_name", "Option %s is selected", x.c_str());
          auto index = id(alarm_stream_name).index_of(x.c_str());
          if (index.has_value()) { //selected value has an index
            ESP_LOGD("alarm_stream_name", "'%s' is at index: %d", x.c_str(), index.value());
            auto option = id(alarm_stream_url).at(index.value());
            if (option.has_value()) { //alarm_stream_url index has been found based on alarm_stream_name
              auto value = option.value();
              ESP_LOGD("alarm_stream_name", "Setting url %s at alarm_stream_url", value.c_str());

              auto alarmStreamUrl = id(alarm_stream_url).make_call();
              alarmStreamUrl.set_option(value.c_str());
              alarmStreamUrl.perform();
            } else {
              ESP_LOGE("alarm_stream_name", "Index %d does not exist at alarm_stream_url", index.has_value());
            }
          } else {
            ESP_LOGE("alarm_stream_name", "There is no option '%s'", x.c_str());
          }
  - name: Display mode
    platform: template
    id: display_mode
    options:
     - "Full"
     - "Minimum night only"
     - "Minimum"
    optimistic: true
    restore_value: true

switch:
  - name: "Display on"
    platform: template
    id: display_on
    optimistic: true
    restore_mode: ALWAYS_ON
    on_turn_on:
      then:
        - script.execute:
            id: display_off_script
  - name: "Display on/off automatically"
    platform: template
    id: display_on_off_automatically
    optimistic: true
    restore_mode: RESTORE_DEFAULT_OFF
    on_turn_on:
      then:
        - script.execute:
            id: display_off_script
        - switch.turn_on: display_on            
    on_turn_off:
      then:
        - script.stop: display_off_script
  - name: "Alarm enabled"
    platform: template
    id: alarm_enabled
    optimistic: true
    restore_mode: RESTORE_DEFAULT_OFF
    entity_category: config
    on_turn_on:
      then:
        - script.execute:
            id: set_alarm_last_off
  - name: "Snooze on"
    platform: template
    id: snooze_on
    optimistic: true
    restore_mode: RESTORE_DEFAULT_OFF
    entity_category: config
    on_turn_on:
      then:
        - if:
            condition:
              lambda: 'return (id(time_sync_done) == true);'
            then:
              - if:
                  condition:
                    and:
                      - switch.is_on: alarm_on
                      - switch.is_off: sleep_timer_on
                  then:
                    - script.execute:
                        id: set_schedule_trigger_time_script
                        index: 6
                    - switch.turn_off: alarm_on
                  else:
                    - switch.turn_off: snooze_on
    on_turn_off:
      - script.execute:
          id: display_off_script
      - script.execute:
          id: set_snooze_timestamp
          timestamp: 0
  - name: "Home assistant 1 enabled"
    platform: template
    id: ha_1_enabled
    optimistic: true
    restore_mode: RESTORE_DEFAULT_OFF
    entity_category: config
  - name: "Home assistant 1 alarmed"
    platform: template
    id: ha_1_alarmed
    optimistic: true
    restore_mode: RESTORE_DEFAULT_OFF
    entity_category: config
  - name: "Home Assistant 1 on"
    platform: template
    id: ha_1_on
    optimistic: true
    restore_mode: ALWAYS_OFF
    on_turn_on:
      - delay: 60s
      - switch.turn_off: ha_1_on
    entity_category: config
  - name: "Home assistant 2 enabled"
    platform: template
    id: ha_2_enabled
    optimistic: true
    restore_mode: RESTORE_DEFAULT_OFF
    entity_category: config
  - name: "Home assistant 2 alarmed"
    platform: template
    id: ha_2_alarmed
    optimistic: true
    restore_mode: RESTORE_DEFAULT_OFF
    entity_category: config
  - name: "Home Assistant 2 on"
    platform: template
    id: ha_2_on
    optimistic: true
    restore_mode: ALWAYS_OFF
    on_turn_on:
      - delay: 60s
      - switch.turn_off: ha_2_on
    entity_category: config
  - name: "Home assistant 3 enabled"
    platform: template
    id: ha_3_enabled
    optimistic: true
    restore_mode: RESTORE_DEFAULT_OFF
    entity_category: config
  - name: "Home assistant 3 alarmed"
    platform: template
    id: ha_3_alarmed
    optimistic: true
    restore_mode: RESTORE_DEFAULT_OFF
    entity_category: config
  - name: "Home Assistant 3 on"
    platform: template
    id: ha_3_on
    optimistic: true
    restore_mode: ALWAYS_OFF
    on_turn_on:
      - delay: 60s
      - switch.turn_off: ha_3_on
    entity_category: config
  - name: "Home assistant 4 enabled"
    platform: template
    id: ha_4_enabled
    optimistic: true
    restore_mode: RESTORE_DEFAULT_OFF
    entity_category: config
  - name: "Home assistant 4 alarmed"
    platform: template
    id: ha_4_alarmed
    optimistic: true
    restore_mode: RESTORE_DEFAULT_OFF
    entity_category: config
  - name: "Home Assistant 4 on"
    platform: template
    id: ha_4_on
    optimistic: true
    restore_mode: ALWAYS_OFF
    on_turn_on:
      - delay: 60s
      - switch.turn_off: ha_4_on
    entity_category: config
  - name: "Alarm on"
    platform: template
    id: alarm_on
    optimistic: true
    restore_mode: RESTORE_DEFAULT_OFF
    entity_category: config
    on_turn_on:
      - lambda:
          //sync preferences now to flash, so alarm_on is set if we crashes!
          global_preferences->sync();
          int iTimestampForAlarm = id(ntp).now().timestamp;
          std::string sTimestampForAlarm = to_string(iTimestampForAlarm);
          ESP_LOGD("alarm_on", "timestampForAlarm %s", sTimestampForAlarm.c_str());
          id(alarm_on_timestamp).publish_state(sTimestampForAlarm);
      - switch.turn_on: display_on
      - if:
          condition:
            switch.is_on: music_on
          then:
            switch.turn_off: alarm_on
          else:
            - wait_until:
                lambda: 'return (id(time_sync_done) == true);'
            - script.execute:
                id: play_url
    on_turn_off:
      - script.execute:
          id: display_off_script
      - switch.turn_off: alarm_on_local
      - if:
          condition:
            switch.is_off: music_on
          then:
            - if:
                condition:
                  lambda: 'return (id(time_sync_done) == true);'
                then:
                  - media_player.stop:
            - script.execute:
                id: set_alarm_last_off
            - script.execute: #set volume back to default
                id: set_volume
                volume: !lambda "return id(alarm_volume).state;"
  - name: "Alarm on local"
    platform: template
    id: alarm_on_local
    optimistic: true
    internal: true
    restore_mode: RESTORE_DEFAULT_OFF
    on_turn_off:
      - mixer_speaker.apply_ducking:  # Stop ducking the media stream over 2 seconds
          id: media_spk_mixer_input
          decibel_reduction: 0
          duration: 2.0s
    on_turn_on:
        # Duck media audio by 20 decibels instantly
        - mixer_speaker.apply_ducking:
            id: media_spk_mixer_input
            decibel_reduction: 20
            duration: 0.0s
        - switch.turn_on: display_on
        - while:
            condition:
              switch.is_on: alarm_on_local
            then:
              # Play the alarm sound as an announcement
              - media_player.speaker.play_on_device_media_file:
                  media_file: alarm_sound
                  announcement: true
              # Wait until the alarm sound starts playing
              - wait_until:
                  media_player.is_announcing:
              # Wait until the alarm sound stops playing
              - wait_until:
                  not:
                    media_player.is_announcing:
  - name: "Music on"
    platform: template
    id: music_on
    optimistic: true
    restore_mode: RESTORE_DEFAULT_OFF
    entity_category: config
    on_turn_on:
      - if:
          condition:
            switch.is_on: alarm_on
          then:
            switch.turn_off: music_on
          else:
            - if: #if media player is not playing, or not announcing, then play music
                all:
                  - not:
                      media_player.is_announcing:
                  - media_player.is_idle:
                then:
                  - wait_until:
                      lambda: 'return (id(time_sync_done) == true);'
                  - logger.log: "Time sync is done, currently no playback, enabling playback"
                  - script.execute:
                      id: play_url
    on_turn_off:
      - script.execute:
          id: display_off_script
      - if:
          condition:
            switch.is_off: alarm_on
          then:
            - media_player.stop:
            - script.execute:
                id: set_alarm_last_off
            - script.execute: #set volume back to default
                id: set_volume
                volume: !lambda "return id(alarm_volume).state;"
  - name: "Restart"
    platform: restart
    id: clock_restart_switch
  - name: "Sleep timer enabled"
    platform: template
    id: sleep_timer_enabled
    optimistic: true
    restore_mode: RESTORE_DEFAULT_OFF
    entity_category: config
  - name: "Sleep timer on"
    platform: template
    id: sleep_timer_on
    optimistic: true
    restore_mode: RESTORE_DEFAULT_OFF
    entity_category: config
    on_turn_on:
      then:
        - if:
            condition:
              lambda: 'return (id(time_sync_done) == true);'
            then:
              - script.execute:
                  id: set_schedule_trigger_time_script
                  index: 5
    on_turn_off:
      then:
        - if:
            condition:
              lambda: 'return (id(time_sync_done) == true);'
            then:
              - switch.turn_off: music_on
              - number.set:
                  id: sleep_timer_timestamp
                  value: 0
  - name: "Clock on display"
    platform: template
    id: clock_on_display
    optimistic: true
    restore_mode: ALWAYS_ON
    entity_category: config
  - name: "Night mode"
    platform: template
    id: night_mode
    optimistic: true
    restore_mode: RESTORE_DEFAULT_OFF
    entity_category: config
  - name: "Night mode automatically"
    platform: template
    id: night_mode_automatically
    optimistic: true
    restore_mode: RESTORE_DEFAULT_ON
    entity_category: config

display:
  - platform: ssd1306_i2c
    id: alarmdisplay
    model: ${display_model}
    #reset_pin: D0
    address: 0x3C
    rotation: ${display_rotation}
    contrast: 1
    update_interval: 500ms
    pages:
      - id: page1 #clock page
        lambda: |-
          if (!id(display_on).state) {
            // Turn the whole display off
            it.fill(COLOR_OFF);
            return;
          }
          auto time = id(ntp).now();
          time_t currentTime = time.timestamp;
          char seconds[15];
          strftime(seconds, sizeof(seconds), "%S", localtime(&currentTime));
          int shouldBlink = atoi(seconds) % 2;
          bool is_night_mode = id(night_mode).state;
          bool showClock = id(clock_on_display).state;
          std::string language = "${language}";

          auto index = id(display_mode).active_index();
          int displayMode = 0;
          if (index.has_value()) {
            if (index.value() == 1 && is_night_mode) {
              //minimum night only
              displayMode = 1;
            }
            else if (index.value() == 2) {
              //minimum
              displayMode = 2;
            }
          }

          //determine font
          auto timeFont51 = id(robotomedium51);
          auto timeFont20 = id(robotomedium20);
          if (displayMode == 1 || displayMode == 2) {
            timeFont51 = id(robotothin51);
            timeFont20 = id(robotothin20);
          }

          if (!is_night_mode) {
            id(contrast_target) = id(screen_contrast_day).state / 100.0f;
          } else {
            id(contrast_target) = id(screen_contrast_night).state / 100.0f;
          }
          id(smooth_contrast).execute();

          //status bar
          if (id(music_on).state && shouldBlink) { //music icon
            it.printf(0, 0, id(robotomedium20), TextAlign::LEFT, "\U000F0387");
          }
          else if (id(alarm_on).state && !id(sleep_timer_on).state) { //alarm on
            if (shouldBlink) {
              it.printf(0, 0, id(robotomedium20), TextAlign::LEFT, "\U000F0E71");
            }
          }
          else if (id(alarm_enabled).state) { //alarm enabled
            it.printf(0, 0, id(robotomedium20), TextAlign::LEFT, "\U000F0020");
          }

          //snooze
          if (id(snooze_on).state) {
            it.printf(27, 0, id(robotomedium20), TextAlign::LEFT, "\U000F068E");
          }

          //ha
          int calculated_width;
          int calculated_height;
          int calculated_x;
          int calculated_y;
          std::string displayString = "\U000F07D0";
          if (id(api_connected)) {
            int leftBase = it.get_width()/2;
            int iconLeftRightMargin = 2;
            int iconTopMargin = 4;
            int iconBottomMargin = 3;

            it.get_text_bounds(0, 0, displayString.c_str(), id(robotomedium30), TextAlign::CENTER, &calculated_x, &calculated_y, &calculated_width, &calculated_height); //calculate icon dimensions
            int iconHeightHalf = (calculated_height/2)-5; //a small correction due to CENTER being used as alignment
            //show ha icon
            it.printf(leftBase, iconHeightHalf, id(robotomedium20), TextAlign::CENTER, "\U000F07D0");

            //hide the part that is disabled
            if ((!id(ha_1_on).state && id(ha_1_enabled).state && ((id(alarm_enabled).state && id(ha_1_alarmed).state) || !id(ha_1_alarmed).state)) || (id(ha_1_on).state && shouldBlink)) {
              //the icon should be visible
            }
            else {
                it.printf(leftBase+iconLeftRightMargin, iconHeightHalf+iconBottomMargin, id(robotomedium15), COLOR_OFF, TextAlign::BOTTOM_RIGHT, "\U000F0764");
            }
            if ((!id(ha_2_on).state && id(ha_2_enabled).state && ((id(alarm_enabled).state && id(ha_2_alarmed).state) || !id(ha_2_alarmed).state)) || (id(ha_2_on).state && shouldBlink)) {
              //the icon should be visible
            }
            else {
                it.printf(leftBase-iconLeftRightMargin, iconHeightHalf+iconBottomMargin, id(robotomedium15), COLOR_OFF, TextAlign::BOTTOM_LEFT, "\U000F0764");
            }
            if ((!id(ha_3_on).state && id(ha_3_enabled).state && ((id(alarm_enabled).state && id(ha_3_alarmed).state) || !id(ha_3_alarmed).state)) || (id(ha_3_on).state && shouldBlink)) {
              //the icon should be visible
            }
            else {
              it.printf(leftBase+iconLeftRightMargin, iconHeightHalf-iconTopMargin, id(robotomedium15), COLOR_OFF, TextAlign::TOP_RIGHT, "\U000F0764");
            }
            if ((!id(ha_4_on).state && id(ha_4_enabled).state && ((id(alarm_enabled).state && id(ha_4_alarmed).state) || !id(ha_4_alarmed).state)) || (id(ha_4_on).state && shouldBlink)) {
              //the icon should be visible
            }
            else {
              it.printf(leftBase-iconLeftRightMargin, iconHeightHalf-iconTopMargin, id(robotomedium15), COLOR_OFF, TextAlign::TOP_LEFT, "\U000F0764");
            }
          }
          else {
            it.printf(it.get_width()/2, 0, id(robotomedium20), TextAlign::TOP_CENTER, "\U000F1A47");
          }

          //sleep timer
          if ((!id(sleep_timer_on).state && id(sleep_timer_enabled).state) || (id(sleep_timer_on).state && shouldBlink)) {
            it.printf((it.get_width()/2)+16, 0, id(robotomedium20), TextAlign::LEFT, "\U000F1ADD");
          }

          //wifi
          if (isnan(id(wifi_signal_percent).state)) {
            it.printf(it.get_width(), 0, id(robotomedium20), TextAlign::RIGHT, "\U000F092E"); // WifiStrengthOffOutline
          }
          else if (displayMode == 0) {
            int wifiStrength = id(wifi_signal_percent).state;
            if (wifiStrength > 75) {
              it.printf(it.get_width(), 0, id(robotomedium20), TextAlign::RIGHT, "\U000F0928"); // WifiStrength4
            }
            else if (wifiStrength > 50) {
              it.printf(it.get_width(), 0, id(robotomedium20), TextAlign::RIGHT, "\U000F0925"); // WifiStrength3
            }
            else if (wifiStrength > 30) {
              it.printf(it.get_width(), 0, id(robotomedium20), TextAlign::RIGHT, "\U000F0922"); // WifiStrength2
            }
            else if (wifiStrength > 10) {
              it.printf(it.get_width(), 0, id(robotomedium20), TextAlign::RIGHT, "\U000F091F"); // WifiStrength1
            }
            else {
              it.printf(it.get_width(), 0, id(robotomedium20), TextAlign::RIGHT, "\U000F092F"); // WifiStrengthOutline
            }
          }

          if (it.get_width() == 128 && it.get_height() == 128) { //sh1107
            // convert ESPTime to struct tm (no Pointer!)
            struct tm cTime = time.to_c_tm();

            // Get englisch weekday
            char cMonth[4];
            strftime(cMonth, sizeof(cMonth), "%a", &cTime);

            std::string sMonth;
            sMonth = cMonth; // fallback
            if (language == "NL") {
              if (strcmp(cMonth, "Sun") == 0) sMonth = "Zo";
              else if (strcmp(cMonth, "Mon") == 0) sMonth = "Ma";
              else if (strcmp(cMonth, "Tue") == 0) sMonth = "Di";
              else if (strcmp(cMonth, "Wed") == 0) sMonth = "Wo";
              else if (strcmp(cMonth, "Thu") == 0) sMonth = "Do";
              else if (strcmp(cMonth, "Fri") == 0) sMonth = "Fr";
              else if (strcmp(cMonth, "Sat") == 0) sMonth = "Za";
            }
            else  if (language == "DE") {
              if (strcmp(cMonth, "Sun") == 0) sMonth = "So";
              else if (strcmp(cMonth, "Mon") == 0) sMonth = "Mo";
              else if (strcmp(cMonth, "Tue") == 0) sMonth = "Di";
              else if (strcmp(cMonth, "Wed") == 0) sMonth = "Mi";
              else if (strcmp(cMonth, "Thu") == 0) sMonth = "Do";
              else if (strcmp(cMonth, "Fri") == 0) sMonth = "Fr";
              else if (strcmp(cMonth, "Sat") == 0) sMonth = "Sa";
            }
            it.print(0, (it.get_width()/2)-10, timeFont20, TextAlign::BOTTOM_LEFT, sMonth.c_str());
            it.strftime(0, (it.get_width()/2)-10, timeFont20, TextAlign::TOP_LEFT, "%d-%m", time);

            std::string preZeroHour = "";
            std::string preZeroMinute = "";
            if (id(alarm_enabled).state && !id(snooze_on).state) {
              if (id(alarm_hour).state < 10) {
                preZeroHour = "0";
              }
              if (id(alarm_minute).state < 10) {
                preZeroMinute = "0";
              }
              it.printf(it.get_width(), (it.get_height()/2), timeFont20, TextAlign::CENTER_RIGHT, "%s%i:%s%i", preZeroHour.c_str(), (int)id(alarm_hour).state, preZeroMinute.c_str(), (int)id(alarm_minute).state);
            }
            else if (id(alarm_enabled).state && id(snooze_on).state) {
              time_t snoozeTime = id(snooze_timestamp);
              char strForDisplay[6];
              strftime(strForDisplay, sizeof(strForDisplay), "%H:%M", localtime(&snoozeTime));
              it.printf(it.get_width(), (it.get_height()/2), timeFont20, TextAlign::CENTER_RIGHT, "%s", strForDisplay);
            }
          }
          //end statusbar

          if (showClock) {
            //the font will be placed too high by default
            int fontMarginBottomCorrection = 10;

            displayString = ":";
            int timeY = it.get_height();
            timeY = (timeY + fontMarginBottomCorrection);
            it.get_text_bounds(0, 0, displayString.c_str(), timeFont51, TextAlign::TOP_CENTER, &calculated_x, &calculated_y, &calculated_width, &calculated_height); //calculate second indicator width

            if(!id(time_sync_done)) {
              it.print(it.get_width()/2, timeY, timeFont51, TextAlign::BOTTOM_CENTER, ".....");
            }
            else {
              it.strftime((it.get_width()/2)-(calculated_width/2), timeY, timeFont51, TextAlign::BOTTOM_RIGHT, "%H", time);
              if((displayMode == 1 || displayMode == 2) || shouldBlink) {
                it.printf((it.get_width()/2), timeY, timeFont51, TextAlign::BOTTOM_CENTER, ":");
              }
              it.strftime((it.get_width()/2)+(calculated_width/2), timeY, timeFont51, TextAlign::BOTTOM_LEFT, "%M", time);
            }
          }

          id(current_page_id) = 1;
      - id: page2 #Alarm clock setting page
        lambda: |-
          auto time = id(ntp).now();
          time_t currentTime = time.timestamp;
          char seconds[15];
          strftime(seconds, sizeof(seconds), "%S", localtime(&currentTime));
          int shouldBlink = atoi(seconds) % 2;

          int calculated_width;
          int calculated_height;
          int calculated_x;
          int calculated_y;
          std::string timeString = ":";
          int timeY = it.get_height();
          it.get_text_bounds(0, 0, timeString.c_str(), id(robotomedium30), TextAlign::TOP_CENTER, &calculated_x, &calculated_y, &calculated_width, &calculated_height); //calculate second indicator width
          int indicatorWidth = calculated_width;

          //alarm clock icon
          it.printf(0, (it.get_height()/2), id(robotomedium20), TextAlign::CENTER_LEFT, "\U000F0020");

          //alarm clock
          int rotate_switch_single_value = id(rotate_switch_single);

          if ((shouldBlink && rotate_switch_single_value == 1) || rotate_switch_single_value != 1) {
            if (id(alarm_hour).state > 9) {
              it.printf((it.get_width()/2)-(indicatorWidth/2), (it.get_height()/2), id(robotomedium30), TextAlign::CENTER_RIGHT, "%i", (int)id(alarm_hour).state);
            }
            else {
              it.printf((it.get_width()/2)-(indicatorWidth/2), (it.get_height()/2), id(robotomedium30), TextAlign::CENTER_RIGHT, "0%i", (int)id(alarm_hour).state);
            }
          }
          it.printf((it.get_width()/2), (it.get_height()/2), id(robotomedium30), TextAlign::CENTER, ":");
          if ((shouldBlink && rotate_switch_single_value == 2) || rotate_switch_single_value != 2) {
            if (id(alarm_minute).state > 9) {
              it.printf((it.get_width()/2)+(indicatorWidth/2), (it.get_height()/2), id(robotomedium30), TextAlign::CENTER_LEFT, "%i", (int)id(alarm_minute).state);
            }
            else {
              it.printf((it.get_width()/2)+(indicatorWidth/2), (it.get_height()/2), id(robotomedium30), TextAlign::CENTER_LEFT, "0%i", (int)id(alarm_minute).state);
            }
          }

          if (id(alarm_enabled).state) {
            it.printf(it.get_width(), (it.get_height()/2), id(robotomedium20), TextAlign::CENTER_RIGHT, "\U000F0C52");
          }
          else {
            it.printf(it.get_width(), (it.get_height()/2), id(robotomedium20), TextAlign::CENTER_RIGHT, "\U000F0131");
          }

          id(current_page_id) = 2;
      - id: page3 #HA 1 page
        lambda: |-
          //https://gist.github.com/alvesvaren/767d9585f0ecbef18ef1c7c0492c4332
          auto time = id(ntp).now();
          time_t currentTime = time.timestamp;
          char seconds[15];
          strftime(seconds, sizeof(seconds), "%S", localtime(&currentTime));
          int shouldBlink = atoi(seconds) % 2;
          int ha_value = id(ha_1_pre_minute).state;
          int rotate_switch_single_value = id(rotate_switch_single);

          it.printf(it.get_width()/2, 0, id(robotomedium20), TextAlign::TOP_CENTER, "HA 1");

          //the font will be placed too high by default
          int fontMarginBottomCorrection = 10;

          int calculated_width;
          int calculated_height;
          int calculated_x;
          int calculated_y;
          std::string displayString = "\U000F07D0";
          it.get_text_bounds(0, 0, displayString.c_str(), id(robotomedium30), TextAlign::TOP_CENTER, &calculated_x, &calculated_y, &calculated_width, &calculated_height); //calculate icon dimensions
          int iconWidthHalf = calculated_width/2;

          //ha icon
          it.printf(iconWidthHalf, it.get_height()/2, id(robotomedium20), TextAlign::CENTER, "\U000F07D0");

          int iconLeftRightMargin = 2;
          int iconTopMargin = 4;
          int iconBottomMargin = 3;

          //ha icon hide
          if (shouldBlink) {
            //it.printf(iconWidthHalf+iconLeftRightMargin, (it.get_height()/2)+iconBottomMargin, id(robotomedium15), COLOR_OFF, TextAlign::BOTTOM_RIGHT, "\U000F0764");
            it.printf(iconWidthHalf-iconLeftRightMargin, (it.get_height()/2)+iconBottomMargin, id(robotomedium15), COLOR_OFF, TextAlign::BOTTOM_LEFT, "\U000F0764");
            it.printf(iconWidthHalf+iconLeftRightMargin, (it.get_height()/2)-iconTopMargin, id(robotomedium15), COLOR_OFF, TextAlign::TOP_RIGHT, "\U000F0764");
            it.printf(iconWidthHalf-iconLeftRightMargin, (it.get_height()/2)-iconTopMargin, id(robotomedium15), COLOR_OFF, TextAlign::TOP_LEFT, "\U000F0764");
          }

          //ha value
          if ((shouldBlink && rotate_switch_single_value == 1) || rotate_switch_single_value != 1) {
            if (it.get_width() == 128 && it.get_height() == 128) { //sh1107
              it.printf((it.get_width()/2), (it.get_height()/2), id(robotomedium40), TextAlign::CENTER, "%i", (int)ha_value);
            }
            else {
              it.printf((it.get_width()/2), it.get_height()+fontMarginBottomCorrection, id(robotomedium40), TextAlign::BOTTOM_CENTER, "%i", (int)ha_value);
            }
          }

          //ha enabled
          if (id(ha_1_enabled).state) {
            it.printf(it.get_width(), (it.get_height()/2), id(robotomedium20), TextAlign::CENTER_RIGHT, "\U000F0C52");
          }
          else {
            it.printf(it.get_width(), (it.get_height()/2), id(robotomedium20), TextAlign::CENTER_RIGHT, "\U000F0131");
          }

          //ha alarmed
          it.get_text_bounds(0, 0, displayString.c_str(), id(robotomedium20), TextAlign::TOP_CENTER, &calculated_x, &calculated_y, &calculated_width, &calculated_height); //calculate icon dimensions
          if (id(ha_1_alarmed).state) {
            it.printf(it.get_width(), (it.get_height()/2)+calculated_height, id(robotomedium20), TextAlign::CENTER_RIGHT, "\U000F0021");
          }
          else {
            it.printf(it.get_width(), (it.get_height()/2)+calculated_height, id(robotomedium20), TextAlign::CENTER_RIGHT, "\U000F0023");
          }

          id(current_page_id) = 3;
      - id: page4 #HA 2 page
        lambda: |-
          auto time = id(ntp).now();
          time_t currentTime = time.timestamp;
          char seconds[15];
          strftime(seconds, sizeof(seconds), "%S", localtime(&currentTime));
          int shouldBlink = atoi(seconds) % 2;
          int ha_value = id(ha_2_pre_minute).state;
          int rotate_switch_single_value = id(rotate_switch_single);

          it.printf(it.get_width()/2, 0, id(robotomedium20), TextAlign::TOP_CENTER, "HA 2");

          //the font will be placed too high by default
          int fontMarginBottomCorrection = 10;

          int calculated_width;
          int calculated_height;
          int calculated_x;
          int calculated_y;
          std::string displayString = "\U000F07D0";
          it.get_text_bounds(0, 0, displayString.c_str(), id(robotomedium30), TextAlign::TOP_CENTER, &calculated_x, &calculated_y, &calculated_width, &calculated_height); //calculate icon dimensions
          int iconWidthHalf = calculated_width/2;

          //ha icon
          it.printf(iconWidthHalf, it.get_height()/2, id(robotomedium20), TextAlign::CENTER, "\U000F07D0");

          int iconLeftRightMargin = 2;
          int iconTopMargin = 4;
          int iconBottomMargin = 3;

          //ha icon hide
          if (shouldBlink) {
            it.printf(iconWidthHalf+iconLeftRightMargin, (it.get_height()/2)+iconBottomMargin, id(robotomedium15), COLOR_OFF, TextAlign::BOTTOM_RIGHT, "\U000F0764");
            //it.printf(iconWidthHalf-iconLeftRightMargin, (it.get_height()/2)+iconBottomMargin, id(robotomedium15), COLOR_OFF, TextAlign::BOTTOM_LEFT, "\U000F0764");
            it.printf(iconWidthHalf+iconLeftRightMargin, (it.get_height()/2)-iconTopMargin, id(robotomedium15), COLOR_OFF, TextAlign::TOP_RIGHT, "\U000F0764");
            it.printf(iconWidthHalf-iconLeftRightMargin, (it.get_height()/2)-iconTopMargin, id(robotomedium15), COLOR_OFF, TextAlign::TOP_LEFT, "\U000F0764");
          }

          //ha value
          if ((shouldBlink && rotate_switch_single_value == 1) || rotate_switch_single_value != 1) {
            if (it.get_width() == 128 && it.get_height() == 128) { //sh1107
              it.printf((it.get_width()/2), (it.get_height()/2), id(robotomedium40), TextAlign::CENTER, "%i", (int)ha_value);
            }
            else {
              it.printf((it.get_width()/2), it.get_height()+fontMarginBottomCorrection, id(robotomedium40), TextAlign::BOTTOM_CENTER, "%i", (int)ha_value);
            }
          }

          //ha enabled
          if (id(ha_2_enabled).state) {
            it.printf(it.get_width(), (it.get_height()/2), id(robotomedium20), TextAlign::CENTER_RIGHT, "\U000F0C52");
          }
          else {
            it.printf(it.get_width(), (it.get_height()/2), id(robotomedium20), TextAlign::CENTER_RIGHT, "\U000F0131");
          }

          //ha alarmed
          it.get_text_bounds(0, 0, displayString.c_str(), id(robotomedium20), TextAlign::TOP_CENTER, &calculated_x, &calculated_y, &calculated_width, &calculated_height); //calculate icon dimensions
          if (id(ha_2_alarmed).state) {
            it.printf(it.get_width(), (it.get_height()/2)+calculated_height, id(robotomedium20), TextAlign::CENTER_RIGHT, "\U000F0021");
          }
          else {
            it.printf(it.get_width(), (it.get_height()/2)+calculated_height, id(robotomedium20), TextAlign::CENTER_RIGHT, "\U000F0023");
          }

          id(current_page_id) = 4;
      - id: page5 #HA 3 page
        lambda: |-
          auto time = id(ntp).now();
          time_t currentTime = time.timestamp;
          char seconds[15];
          strftime(seconds, sizeof(seconds), "%S", localtime(&currentTime));
          int shouldBlink = atoi(seconds) % 2;
          int ha_value = id(ha_3_pre_minute).state;
          int rotate_switch_single_value = id(rotate_switch_single);

          it.printf(it.get_width()/2, 0, id(robotomedium20), TextAlign::TOP_CENTER, "HA 3");

          //the font will be placed too high by default
          int fontMarginBottomCorrection = 10;

          int calculated_width;
          int calculated_height;
          int calculated_x;
          int calculated_y;
          std::string displayString = "\U000F07D0";
          it.get_text_bounds(0, 0, displayString.c_str(), id(robotomedium30), TextAlign::TOP_CENTER, &calculated_x, &calculated_y, &calculated_width, &calculated_height); //calculate icon dimensions
          int iconWidthHalf = calculated_width/2;

          //ha icon
          it.printf(iconWidthHalf, it.get_height()/2, id(robotomedium20), TextAlign::CENTER, "\U000F07D0");

          int iconLeftRightMargin = 2;
          int iconTopMargin = 4;
          int iconBottomMargin = 3;

          //ha icon hide
          if (shouldBlink) {
            it.printf(iconWidthHalf+iconLeftRightMargin, (it.get_height()/2)+iconBottomMargin, id(robotomedium15), COLOR_OFF, TextAlign::BOTTOM_RIGHT, "\U000F0764");
            it.printf(iconWidthHalf-iconLeftRightMargin, (it.get_height()/2)+iconBottomMargin, id(robotomedium15), COLOR_OFF, TextAlign::BOTTOM_LEFT, "\U000F0764");
            //it.printf(iconWidthHalf+iconLeftRightMargin, (it.get_height()/2)-iconTopMargin, id(robotomedium15), COLOR_OFF, TextAlign::TOP_RIGHT, "\U000F0764");
            it.printf(iconWidthHalf-iconLeftRightMargin, (it.get_height()/2)-iconTopMargin, id(robotomedium15), COLOR_OFF, TextAlign::TOP_LEFT, "\U000F0764");
          }

          //ha value
          if ((shouldBlink && rotate_switch_single_value == 1) || rotate_switch_single_value != 1) {
            if (it.get_width() == 128 && it.get_height() == 128) { //sh1107
              it.printf((it.get_width()/2), (it.get_height()/2), id(robotomedium40), TextAlign::CENTER, "%i", (int)ha_value);
            }
            else {
              it.printf((it.get_width()/2), it.get_height()+fontMarginBottomCorrection, id(robotomedium40), TextAlign::BOTTOM_CENTER, "%i", (int)ha_value);
            }
          }

          //ha enabled
          if (id(ha_3_enabled).state) {
            it.printf(it.get_width(), (it.get_height()/2), id(robotomedium20), TextAlign::CENTER_RIGHT, "\U000F0C52");
          }
          else {
            it.printf(it.get_width(), (it.get_height()/2), id(robotomedium20), TextAlign::CENTER_RIGHT, "\U000F0131");
          }

          //ha alarmed
          it.get_text_bounds(0, 0, displayString.c_str(), id(robotomedium20), TextAlign::TOP_CENTER, &calculated_x, &calculated_y, &calculated_width, &calculated_height); //calculate icon dimensions
          if (id(ha_3_alarmed).state) {
            it.printf(it.get_width(), (it.get_height()/2)+calculated_height, id(robotomedium20), TextAlign::CENTER_RIGHT, "\U000F0021");
          }
          else {
            it.printf(it.get_width(), (it.get_height()/2)+calculated_height, id(robotomedium20), TextAlign::CENTER_RIGHT, "\U000F0023");
          }

          id(current_page_id) = 5;
      - id: page6 #HA 4 page
        lambda: |-
          auto time = id(ntp).now();
          time_t currentTime = time.timestamp;
          char seconds[15];
          strftime(seconds, sizeof(seconds), "%S", localtime(&currentTime));
          int shouldBlink = atoi(seconds) % 2;
          int ha_value = id(ha_4_pre_minute).state;
          int rotate_switch_single_value = id(rotate_switch_single);

          it.printf(it.get_width()/2, 0, id(robotomedium20), TextAlign::TOP_CENTER, "HA 4");

          //the font will be placed too high by default
          int fontMarginBottomCorrection = 10;

          int calculated_width;
          int calculated_height;
          int calculated_x;
          int calculated_y;
          std::string displayString = "\U000F07D0";
          it.get_text_bounds(0, 0, displayString.c_str(), id(robotomedium30), TextAlign::TOP_CENTER, &calculated_x, &calculated_y, &calculated_width, &calculated_height); //calculate icon dimensions
          int iconWidthHalf = calculated_width/2;

          //ha icon
          it.printf(iconWidthHalf, it.get_height()/2, id(robotomedium20), TextAlign::CENTER, "\U000F07D0");

          int iconLeftRightMargin = 2;
          int iconTopMargin = 4;
          int iconBottomMargin = 3;

          //ha icon hide
          if (shouldBlink) {
            it.printf(iconWidthHalf+iconLeftRightMargin, (it.get_height()/2)+iconBottomMargin, id(robotomedium15), COLOR_OFF, TextAlign::BOTTOM_RIGHT, "\U000F0764");
            it.printf(iconWidthHalf-iconLeftRightMargin, (it.get_height()/2)+iconBottomMargin, id(robotomedium15), COLOR_OFF, TextAlign::BOTTOM_LEFT, "\U000F0764");
            it.printf(iconWidthHalf+iconLeftRightMargin, (it.get_height()/2)-iconTopMargin, id(robotomedium15), COLOR_OFF, TextAlign::TOP_RIGHT, "\U000F0764");
            //it.printf(iconWidthHalf-iconLeftRightMargin, (it.get_height()/2)-iconTopMargin, id(robotomedium15), COLOR_OFF, TextAlign::TOP_LEFT, "\U000F0764");
          }

          //ha value
          if ((shouldBlink && rotate_switch_single_value == 1) || rotate_switch_single_value != 1) {
            if (it.get_width() == 128 && it.get_height() == 128) { //sh1107
              it.printf((it.get_width()/2), (it.get_height()/2), id(robotomedium40), TextAlign::CENTER, "%i", (int)ha_value);
            }
            else {
              it.printf((it.get_width()/2), it.get_height()+fontMarginBottomCorrection, id(robotomedium40), TextAlign::BOTTOM_CENTER, "%i", (int)ha_value);
            }
          }

          //ha enabled
          if (id(ha_4_enabled).state) {
            it.printf(it.get_width(), (it.get_height()/2), id(robotomedium20), TextAlign::CENTER_RIGHT, "\U000F0C52");
          }
          else {
            it.printf(it.get_width(), (it.get_height()/2), id(robotomedium20), TextAlign::CENTER_RIGHT, "\U000F0131");
          }

          //ha alarmed
          it.get_text_bounds(0, 0, displayString.c_str(), id(robotomedium20), TextAlign::TOP_CENTER, &calculated_x, &calculated_y, &calculated_width, &calculated_height); //calculate icon dimensions
          if (id(ha_4_alarmed).state) {
            it.printf(it.get_width(), (it.get_height()/2)+calculated_height, id(robotomedium20), TextAlign::CENTER_RIGHT, "\U000F0021");
          }
          else {
            it.printf(it.get_width(), (it.get_height()/2)+calculated_height, id(robotomedium20), TextAlign::CENTER_RIGHT, "\U000F0023");
          }

          id(current_page_id) = 6;
      - id: page7 #Sleep timer
        lambda: |-
          auto time = id(ntp).now();
          time_t currentTime = time.timestamp;
          char seconds[15];
          strftime(seconds, sizeof(seconds), "%S", localtime(&currentTime));
          int shouldBlink = atoi(seconds) % 2;
          int sleep_timer_duration_value = id(sleep_timer_duration).state;
          int rotate_switch_single_value = id(rotate_switch_single);

          it.printf(0, (it.get_height()/2), id(robotomedium20), TextAlign::CENTER_LEFT, "\U000F1ADD");

          if ((shouldBlink && rotate_switch_single_value == 1) || rotate_switch_single_value != 1) {
            it.printf(it.get_width()/2, (it.get_height()/2), id(robotomedium40), TextAlign::CENTER, "%i", sleep_timer_duration_value);
          }

          if (id(sleep_timer_enabled).state) {
            it.printf(it.get_width(), (it.get_height()/2), id(robotomedium20), TextAlign::CENTER_RIGHT, "\U000F0C52");
          }
          else {
            it.printf(it.get_width(), (it.get_height()/2), id(robotomedium20), TextAlign::CENTER_RIGHT, "\U000F0131");
          }

          id(current_page_id) = 7;
      - id: page8 #Radio selector
        lambda: |-
          auto time = id(ntp).now();
          time_t currentTime = time.timestamp;
          char seconds[15];
          strftime(seconds, sizeof(seconds), "%S", localtime(&currentTime));
          int shouldBlink = atoi(seconds) % 2;

          int rotate_switch_single_value = id(rotate_switch_single);

          std::string radioValue = "Unknown";
          auto index = id(alarm_stream_url).active_index();
          if (index.has_value()) {
            auto option = id(alarm_stream_name).at(index.value());
            if (option.has_value()) {
              radioValue = option.value();
            } else {
              ESP_LOGE("alarmdisplay", "Index %d does not exist", index.value());
            }
          } else {
            ESP_LOGE("alarmdisplay", "There is no active index at alarm_stream_url");
          }

          it.printf(it.get_width()/2, 0, id(robotomedium20), TextAlign::TOP_CENTER, "Radio");

          if ((shouldBlink && rotate_switch_single_value == 1) || rotate_switch_single_value != 1) {
            it.printf(it.get_width()/2, it.get_height(), id(robotomedium20), TextAlign::BOTTOM_CENTER, radioValue.c_str());
          }

          id(current_page_id) = 8;
      - id: page10 #Contrast page
        lambda: |-
          bool is_night_mode = id(night_mode).state;

          if (!is_night_mode) {
            alarmdisplay->set_contrast(id(screen_contrast_day).state/100);
          }
          else {
            alarmdisplay->set_contrast(id(screen_contrast_night).state/100);
          }

          it.printf(0, (it.get_height()/2), id(robotomedium20), TextAlign::CENTER_LEFT, "\U000F0197");
          int value = 0;
          if (!is_night_mode) {
            value = id(screen_contrast_day).state;
          }
          else {
            value = id(screen_contrast_night).state;
          }
          ESP_LOGD("alarmdisplay", "Current contrast %i", value);
          it.printf(it.get_width()/2, (it.get_height()/2), id(robotomedium40), TextAlign::CENTER, "%i", value);

          id(current_page_id) = 10;
      - id: page11 #Restart page
        lambda: |-
          it.printf(it.get_width()/2, 0, id(robotomedium20), TextAlign::TOP_CENTER, "Restart?");
          if (id(rotate_switch_single) == 0) { // check active
            it.printf(it.get_width()/2, it.get_height(), id(robotomedium40), TextAlign::BOTTOM_RIGHT, "\U000F0C52");
            it.printf(it.get_width()/2, it.get_height(), id(robotomedium40), TextAlign::BOTTOM_LEFT, "\U000F0157");
          }
          else { //close active
            it.printf(it.get_width()/2, it.get_height(), id(robotomedium40), TextAlign::BOTTOM_RIGHT, "\U000F0132");
            it.printf(it.get_width()/2, it.get_height(), id(robotomedium40), TextAlign::BOTTOM_LEFT, "\U000F0158");
          }

          id(current_page_id) = 11;
      - id: page12 #Volume page
        lambda: |-
          if (!id(display_on).state) {
            // Turn the whole display off
            it.fill(COLOR_OFF);
            return;
          }
          it.printf(0, (it.get_height()/2), id(robotomedium20), TextAlign::CENTER_LEFT, "\U000F057E");
          int value = id(alarm_volume).state;
          it.printf(it.get_width()/2, (it.get_height()/2), id(robotomedium40), TextAlign::CENTER, "%i", value);
          id(current_page_id) = 12;

script:
  - id: rotary_encoder_script
    mode: queued
    parameters:
      clockwise: bool
    then:
      - lambda: |-
          std::string rotation = "on_clockwise";
          if (clockwise == false) {
            rotation = "on_anticlockwise";
          }

          int current_page_id_value = id(current_page_id);
          int rotate_switch_single_value = id(rotate_switch_single);
          int rotate_switch_double_value = id(rotate_switch_double);

          //ESP_LOGD("rotary_encoder_script", "Current page id %i", current_page_id_value);

          if (current_page_id_value == 2) { //alarm clock page
            int hour_value = id(alarm_hour).state;
            int minute_value = id(alarm_minute).state;
            if (rotate_switch_single_value == 1) { //update minutes
              if (clockwise == true) {
                hour_value += 1;
                if (hour_value > 23) {
                  hour_value = 0;
                }
              }
              else {
                hour_value -= 1;
                if (hour_value < 0) {
                  hour_value = 23;
                }
              }
              auto call = id(alarm_hour).make_call();
              call.set_value(hour_value);
              call.perform();
              ESP_LOGD("rotary_encoder_script", "%s setting alarm_hour to %i", rotation.c_str(), hour_value);
            }
            else if (rotate_switch_single_value == 2) { //update minute
              if (clockwise == true) {
                minute_value += 1;
                if (minute_value > 59) {
                  minute_value = 0;
                }
              }
              else {
                minute_value -= 1;
                if (minute_value < 0) {
                  minute_value = 59;
                }
              }
              auto call = id(alarm_minute).make_call();
              call.set_value(minute_value);
              call.perform();
              ESP_LOGD("rotary_encoder_script", "%s setting alarm_minute to %i", rotation.c_str(), alarm_minute);
            }
          }
          else if (current_page_id_value == 3 || current_page_id_value == 4 || current_page_id_value == 5 || current_page_id_value == 6) { //ha pages
            int ha_value = 0;
            if (current_page_id_value == 3) {
              ha_value = id(ha_1_pre_minute).state;
            }
            else if (current_page_id_value == 4) {
              ha_value = id(ha_2_pre_minute).state;
            }
            else if (current_page_id_value == 5) {
              ha_value = id(ha_3_pre_minute).state;
            }
            else if (current_page_id_value == 6) {
              ha_value = id(ha_4_pre_minute).state;
            }
            if (rotate_switch_single_value == 1) { //update ha minutes
              if (clockwise) {
                ha_value += 1;
                if (ha_value > 99) {
                  ha_value = -99;
                }
              }
              else {
                ha_value -= 1;
                if (ha_value < -99) {
                  ha_value = 99;
                }
              }

              if (current_page_id_value == 3) {
                auto call = id(ha_1_pre_minute).make_call();
                call.set_value(ha_value);
                call.perform();
              }
              else if (current_page_id_value == 4) {
                auto call = id(ha_2_pre_minute).make_call();
                call.set_value(ha_value);
                call.perform();
              }
              else if (current_page_id_value == 5) {
                auto call = id(ha_3_pre_minute).make_call();
                call.set_value(ha_value);
                call.perform();
              }
              else if (current_page_id_value == 6) {
                auto call = id(ha_4_pre_minute).make_call();
                call.set_value(ha_value);
                call.perform();
              }
              ESP_LOGD("rotary_encoder_script", "%s setting ha_%i_pre_minute to %i", rotation.c_str(), current_page_id_value-2, ha_value);
            }
          }
          else if (current_page_id_value == 7) { //sleep timer pages
            int sleep_timer_duration_value = id(sleep_timer_duration).state;
            if (rotate_switch_single_value == 1) { //update sleep timer minutes
              if (clockwise) {
                sleep_timer_duration_value += 5;
                if (sleep_timer_duration_value > 180) {
                  sleep_timer_duration_value = 10;
                }
              }
              else {
                sleep_timer_duration_value -= 5;
                if (sleep_timer_duration_value < 10) {
                  sleep_timer_duration_value = 180;
                }
              }

              auto call = id(sleep_timer_duration).make_call();
              call.set_value(sleep_timer_duration_value);
              call.perform();

              ESP_LOGD("rotary_encoder_script", "%s setting sleep_timer_duration to %i", rotation.c_str(), sleep_timer_duration_value);
            }
          }
          else if (current_page_id_value == 8) { //Radio selector page
            auto size = id(alarm_stream_name).size();
            ESP_LOGD("rotary_encoder_script", "alarm_stream_name select has %d options", size);

            auto index = id(alarm_stream_name).active_index();
            if (index.has_value()) {
              ESP_LOGD("rotary_encoder_script", "alarm_stream_name option at index %d is active", index.value());

              int currentIndex = index.value();
              if (clockwise) {
                currentIndex += 1;
                if (currentIndex >= size) {
                  currentIndex = 0;
                }
              }
              else {
                currentIndex -= 1;
                if (currentIndex < 0) {
                  currentIndex = size -1;
                }
              }

              auto alarmStreamName = id(alarm_stream_name).make_call();
              alarmStreamName.set_index(currentIndex);
              alarmStreamName.perform();

              ESP_LOGD("rotary_encoder_script", "alarm_stream_name new selected index is %i", currentIndex);
            } else {
              ESP_LOGD("rotary_encoder_script", "alarm_stream_name no option is active");
            }
          }
          else if (current_page_id_value == 10) { //alarm contrast page
            if (!id(night_mode).state) {
              int screen_contrast_day_value = id(screen_contrast_day).state;
              if (clockwise == true) {
                screen_contrast_day_value += 5;
              }
              else {
                screen_contrast_day_value -= 5;
              }
              auto call = id(screen_contrast_day).make_call();
              call.set_value(screen_contrast_day_value);
              call.perform();
              ESP_LOGD("rotary_encoder_script", "%s setting screen_contrast_day to %i", rotation.c_str(), screen_contrast_day_value);
            }
            else {
              int screen_contrast_night_value = id(screen_contrast_night).state;
              if (clockwise == true) {
                screen_contrast_night_value += 5;
              }
              else {
                screen_contrast_night_value -= 5;
              }
              auto call = id(screen_contrast_night).make_call();
              call.set_value(screen_contrast_night_value);
              call.perform();
              ESP_LOGD("rotary_encoder_script", "%s setting screen_contrast_night to %i", rotation.c_str(), screen_contrast_night_value);
            }
            id(reset_page_script).execute();
          }
          else if (current_page_id_value == 11) { //restart page
            ESP_LOGD("rotary_encoder_script", "Start rotate_switch_single with %i", rotate_switch_single_value);
            if (rotate_switch_single_value == 0) {
              rotate_switch_single_value = 1;
            }
            else {
              rotate_switch_single_value = 0;
            }
            ESP_LOGD("rotary_encoder_script", "Update rotate_switch_single with %i", rotate_switch_single_value);
            id(rotate_switch_single) = rotate_switch_single_value;
            id(reset_page_script).execute();
          }
          else if (current_page_id_value == 12) { //alarm volume page
            int value = id(alarm_volume).state;
            if (clockwise == false) {
              value -=1;
              if (value < 0) {
                value = 0;
              }
            }
            else {
              value +=1;
              if (value > 100) {
                value = 100;
              }
            }

            auto call = id(alarm_volume).make_call();
            call.set_value(value);
            call.perform();
            id(reset_page_script).execute();
          }

          ESP_LOGD("rotary_encoder_script", "Page %i with rotation %s", current_page_id_value, rotation.c_str());
  - id: reset_page_script
    mode: restart
    then:
      - delay: 5000ms
      - script.execute:
          id: reset_page_script_no_timeout
  - id: reset_page_script_no_timeout
    mode: restart
    then:
      - script.execute:
          id: display_off_script
      - display.page.show: !lambda
          id(rotate_switch_single) = 0;
          id(rotate_switch_double) = 0;
          ESP_LOGD("reset_page_script", "Reset page executed");
          return id(page1);
  - id: display_off_script
    mode: restart
    then:
      - delay: 10s
      - if:
          condition:
            and:
              - switch.is_on: display_on_off_automatically
              - switch.is_off: alarm_on
              - switch.is_off: snooze_on
              - switch.is_off: music_on
              - lambda: 'return (id(time_sync_done) == true);'
          then:
            - switch.turn_off: display_on
  - id: set_ha_0_trigger_time_script
    mode: restart
    then:
      - delay: 3000ms
      - script.execute:
          id: set_schedule_trigger_time_script
          index: 1
      - script.execute:
          id: set_schedule_trigger_time_script
          index: 2
      - script.execute:
          id: set_schedule_trigger_time_script
          index: 3
      - script.execute:
          id: set_schedule_trigger_time_script
          index: 4
  - id: set_ha_1_trigger_time_script
    mode: restart
    then:
      - delay: 3000ms
      - script.execute:
          id: set_schedule_trigger_time_script
          index: 1
  - id: set_ha_2_trigger_time_script
    mode: restart
    then:
      - delay: 3000ms
      - script.execute:
          id: set_schedule_trigger_time_script
          index: 2
  - id: set_ha_3_trigger_time_script
    mode: restart
    then:
      - delay: 3000ms
      - script.execute:
          id: set_schedule_trigger_time_script
          index: 3
  - id: set_ha_4_trigger_time_script
    mode: restart
    then:
      - delay: 3000ms
      - script.execute:
          id: set_schedule_trigger_time_script
          index: 4
  - id: set_schedule_trigger_time_script
    mode: queued
    parameters:
      index: int
    then:
      - wait_until:
          lambda: 'return (id(time_sync_done) == true);'
      - lambda: |-
          ESP_LOGD("set_schedule_trigger_time_script", "processing index %i", index);
          char str[20];
          time_t currentTimeForSchedule = id(ntp).now().timestamp;

          //get the midnight of today
          char currentHour[5];
          char currentMinute[5];
          char currentSecond[5];
          strftime(currentHour, sizeof(currentHour), "%H", localtime(&currentTimeForSchedule));
          strftime(currentMinute, sizeof(currentMinute), "%M", localtime(&currentTimeForSchedule));
          strftime(currentSecond, sizeof(currentSecond), "%S", localtime(&currentTimeForSchedule));
          int iCurrentHour = atoi(currentHour);
          int iCurrentMinute = atoi(currentMinute);
          int iCurrentSecond = atoi(currentSecond);
          currentTimeForSchedule -= iCurrentSecond; //second 0 of the current minute

          strftime(str, sizeof(str), "%Y-%m-%d %H:%M:%S", localtime(&currentTimeForSchedule));
          ESP_LOGD("set_schedule_trigger_time_script", "currentTimeForSchedule time %s", str);

          time_t currentTimeMidnight = currentTimeForSchedule;
          int secondsFromMidnight = (iCurrentHour * 60 * 60) + (iCurrentMinute * 60);
          currentTimeMidnight -= secondsFromMidnight;

          strftime(str, sizeof(str), "%Y-%m-%d %H:%M:%S", localtime(&currentTimeMidnight));
          ESP_LOGD("set_schedule_trigger_time_script", "currentTimeMidnight time %s. seconds from midnight is %i", str, secondsFromMidnight);

          //calculate the time the alarm would go off
          int alarmHour = id(alarm_hour).state;
          int alarmMinute = id(alarm_minute).state;
          int alarmTime = (60 * 60 * alarmHour) + (60 * alarmMinute);
          ESP_LOGD("set_schedule_trigger_time_script", "alarmHour %i alarmMinute %i alarmTime %i", alarmHour, alarmMinute, alarmTime);
          time_t newSchedule = currentTimeMidnight + alarmTime;

          //substract the ha_pre_minute to get the time for the required schedule
          if (index == 1) {
            int ha1Seconds = (60 * id(ha_1_pre_minute).state);
            newSchedule += ha1Seconds;
            ESP_LOGD("set_schedule_trigger_time_script", "HA 1 seconds to add %i", ha1Seconds);
          }
          else if (index == 2) {
            int ha2Seconds = (60 * id(ha_2_pre_minute).state);
            newSchedule += ha2Seconds;
            ESP_LOGD("set_schedule_trigger_time_script", "HA 2 seconds to add %i", ha2Seconds);
          }
          else if (index == 3) {
            int ha3Seconds = (60 * id(ha_3_pre_minute).state);
            newSchedule += ha3Seconds;
            ESP_LOGD("set_schedule_trigger_time_script", "HA 3 seconds to add %i", ha3Seconds);
          }
          else if (index == 4) {
            int ha4Seconds = (60 * id(ha_4_pre_minute).state);
            newSchedule += ha4Seconds;
            ESP_LOGD("set_schedule_trigger_time_script", "HA 4 seconds to add %i", ha4Seconds);
          }
          else if (index == 5) { //sleep timer
            int sleepTimerDuration = id(sleep_timer_duration).state;
            ESP_LOGD("set_schedule_trigger_time_script", "sleepTimerDuration time %i", sleepTimerDuration);
            newSchedule = currentTimeForSchedule + (sleepTimerDuration * 60);
          }
          else if (index == 6) { //snooze
            int snoozeDuration = id(snooze_duration).state;
            ESP_LOGD("set_schedule_trigger_time_script", "snoozeDuration time %i", snoozeDuration);
            newSchedule = currentTimeForSchedule + (snoozeDuration * 60);
          }

          strftime(str, sizeof(str), "%Y-%m-%d %H:%M:%S", localtime(&newSchedule));
          ESP_LOGD("set_schedule_trigger_time_script", "newSchedule time %s", str);

          //set the schedule time
          char scheduleHour[5];
          char scheduleMinute[5];
          strftime(scheduleHour, sizeof(scheduleHour), "%H", localtime(&newSchedule));
          strftime(scheduleMinute, sizeof(scheduleMinute), "%M", localtime(&newSchedule));

          //string for display time
          char strForDisplay[6];
          strftime(strForDisplay, sizeof(strForDisplay), "%H:%M", localtime(&newSchedule));

          //current time as timestamp
          int currentTimestamp = currentTimeForSchedule;
          int iNewScheduleTimeStamp = newSchedule;

          //assign the new schedule
          if (index == 1) {
            auto haMinuteNumber1 = id(ha_1_minute).make_call();
            haMinuteNumber1.set_value(atoi(scheduleMinute));
            haMinuteNumber1.perform();

            auto haHourNumber1 = id(ha_1_hour).make_call();
            haHourNumber1.set_value(atoi(scheduleHour));
            haHourNumber1.perform();
            id(ha_1_time).publish_state(strForDisplay);
          }
          else if (index == 2) {
            auto haMinuteNumber2 = id(ha_2_minute).make_call();
            haMinuteNumber2.set_value(atoi(scheduleMinute));
            haMinuteNumber2.perform();

            auto haHourNumber2 = id(ha_2_hour).make_call();
            haHourNumber2.set_value(atoi(scheduleHour));
            haHourNumber2.perform();
            id(ha_2_time).publish_state(strForDisplay);
          }
          else if (index == 3) {
            auto haMinuteNumber3 = id(ha_3_minute).make_call();
            haMinuteNumber3.set_value(atoi(scheduleMinute));
            haMinuteNumber3.perform();

            auto haHourNumber3 = id(ha_3_hour).make_call();
            haHourNumber3.set_value(atoi(scheduleHour));
            haHourNumber3.perform();
            id(ha_3_time).publish_state(strForDisplay);
          }
          else if (index == 4) {
            auto haMinuteNumber4 = id(ha_4_minute).make_call();
            haMinuteNumber4.set_value(atoi(scheduleMinute));
            haMinuteNumber4.perform();

            auto haHourNumber4 = id(ha_4_hour).make_call();
            haHourNumber4.set_value(atoi(scheduleHour));
            haHourNumber4.perform();
            id(ha_4_time).publish_state(strForDisplay);
          }
          else if (index == 5) {
            int sleepTimerTimestamp = id(sleep_timer_timestamp).state;
            if (currentTimestamp > sleepTimerTimestamp) {
              ESP_LOGD("set_schedule_trigger_time_script", "Updating sleep timer time");

              auto sleepTimerTimestampNumber = id(sleep_timer_timestamp).make_call();
              sleepTimerTimestampNumber.set_value(iNewScheduleTimeStamp);
              sleepTimerTimestampNumber.perform();
            }
            else {
              ESP_LOGD("set_schedule_trigger_time_script", "Not updating sleep timer time, current time is before sleeptimer");
            }
          }
          else if (index == 6) {
            int snoozeTimestamp = id(snooze_timestamp);
            if (currentTimestamp > snoozeTimestamp) {
              ESP_LOGD("set_schedule_trigger_time_script", "Updating snooze time with %i", iNewScheduleTimeStamp);
              id(set_snooze_timestamp).execute(iNewScheduleTimeStamp);
            }
            else {
              ESP_LOGD("set_schedule_trigger_time_script", "Not updating snooze time, current time is before snooze");
            }
          }
  - id: check_alarms
    mode: single
    then:
      - lambda: |-
          time_t currentTimeForAlarm = id(ntp).now().timestamp;

          //get time to calculate with
          char cCurrentHour[5];
          char cCurrentMinute[5];
          char cCurrentSecond[5];
          strftime(cCurrentHour, sizeof(cCurrentHour), "%H", localtime(&currentTimeForAlarm));
          strftime(cCurrentMinute, sizeof(cCurrentMinute), "%M", localtime(&currentTimeForAlarm));
          strftime(cCurrentSecond, sizeof(cCurrentSecond), "%S", localtime(&currentTimeForAlarm));
          int iCurrentHour = atoi(cCurrentHour);
          int iCurrentMinute = atoi(cCurrentMinute);
          int iCurrentSecond = atoi(cCurrentSecond);
          int iAlarmHours = id(alarm_hour).state;
          int iAlarmMinutes = id(alarm_minute).state;

          //get the timestamp
          int currentTimeForAlarmTimeStamp = currentTimeForAlarm;

          if (!id(alarm_on).state && id(alarm_enabled).state || id(alarm_on).state) {
            //get the midnight of today
            time_t currentTimeForAlarmMidnight = currentTimeForAlarm; //second 0 of the current minute
            int secondsFromMidnight = (iCurrentHour * 60 * 60) + (iCurrentMinute * 60) + iCurrentSecond;
            currentTimeForAlarmMidnight -= secondsFromMidnight;
            int iCurrentTimeForAlarmMidnight = currentTimeForAlarmMidnight;
            int alarmTimeStamp = iCurrentTimeForAlarmMidnight + (iAlarmHours * 60  * 60) + (iAlarmMinutes * 60);
            int alarmOffTimeStamp = id(alarm_last_off);
            if (!id(alarm_on).state && id(alarm_enabled).state) {
              if (alarmTimeStamp <= currentTimeForAlarmTimeStamp) { //alarm time has passed
                if (alarmOffTimeStamp <= alarmTimeStamp) { //alarm time is after the last time alarm was set to off
                  id(alarm_on).turn_on();
                  ESP_LOGD("check_alarms", "alarm on");
                }
              }
            }
            else if (id(alarm_on).state) { // increase volume with alarmVolumeIncrease if it is on for alarmVolumeIncreaseDuration seconds
              auto aAlarmTimeStamp = parse_number<int>(id(alarm_on_timestamp).state);
              if (aAlarmTimeStamp.has_value()) {
                time_t tAlarmTimeStamp = aAlarmTimeStamp.value();
                char cAlarmOnTimestampHour[5];
                char cAlarmOnTimestampMinute[5];
                strftime(cAlarmOnTimestampHour, sizeof(cAlarmOnTimestampHour), "%H", localtime(&tAlarmTimeStamp));
                strftime(cAlarmOnTimestampMinute, sizeof(cAlarmOnTimestampMinute), "%M", localtime(&tAlarmTimeStamp));
                int iAlarmOnTimestampHour = atoi(cAlarmOnTimestampHour);
                int iAlarmOnTimestampMinute = atoi(cAlarmOnTimestampMinute);
                alarmTimeStamp = iCurrentTimeForAlarmMidnight + (iAlarmOnTimestampHour * 60  * 60) + (iAlarmOnTimestampMinute * 60);
                int alarmVolumeIncreaseDuration = id(alarm_volume_increase_duration).state;
                int alarmVolumeIncrease = id(alarm_volume_increase).state;
                if (alarmVolumeIncreaseDuration != 0 && alarmVolumeIncrease != 0) {
                  if (currentTimeForAlarmTimeStamp != alarmTimeStamp) { // its not at 0
                    int alarmDuration = currentTimeForAlarmTimeStamp - alarmTimeStamp;
                    int result = alarmDuration % alarmVolumeIncreaseDuration;
                    //ESP_LOGD("check_alarms", "alarmDuration %i", alarmDuration);
                    //ESP_LOGD("check_alarms", "result 1 %i", result);
                    if (result == 0) { //the remainder is 0, which means alarmVolumeIncreaseDuration has passed
                      ESP_LOGD("check_alarms", "alarmVolumeIncreaseDuration %i seconds since alarm start %i has passed", alarmVolumeIncreaseDuration, tAlarmTimeStamp);
                      //ESP_LOGD("check_alarms", "currentTimeForAlarmTimeStamp %i", currentTimeForAlarmTimeStamp);
                      //ESP_LOGD("check_alarms", "alarmTimeStamp %i", alarmTimeStamp);
                      //ESP_LOGD("check_alarms", "result 2 %i", result);
                      //ESP_LOGD("check_alarms", "alarmVolumeIncreaseDuration %i", alarmVolumeIncreaseDuration);
                      result = alarmDuration / alarmVolumeIncreaseDuration;
                      ///ESP_LOGD("check_alarms", "result 3 %i", result);
                      if (result > 0) {
                        int newVolume = id(alarm_volume).state + (result * alarmVolumeIncrease); //add number of passed alarmVolumeIncreaseDuration to the known base volume
                        if (newVolume > 100) {
                          newVolume = 100;
                        }
                        id(set_volume).execute(newVolume);
                        ESP_LOGD("check_alarms", "Updating volume with %i", newVolume);
                      }
                    }
                  }
                }
              }
              else {
                ESP_LOGW("check_alarms", "alarm_on_timestamp does not have a value, unable to determine volume increase");
              }
            }
          }

          if (iCurrentHour == id(ha_1_hour).state && iCurrentMinute == id(ha_1_minute).state && id(ha_1_enabled).state) {
            if (id(alarm_enabled).state && id(ha_1_alarmed).state || !id(ha_1_alarmed).state) {
              id(ha_1_on).turn_on();
              ESP_LOGD("check_alarms", "ha 1 on");
            }
          }
          if (iCurrentHour == id(ha_2_hour).state && iCurrentMinute == id(ha_2_minute).state && id(ha_2_enabled).state) {
            if (id(alarm_enabled).state && id(ha_2_alarmed).state || !id(ha_2_alarmed).state) {
              id(ha_2_on).turn_on();
              ESP_LOGD("check_alarms", "ha 2 on");
            }
          }
          if (iCurrentHour == id(ha_3_hour).state && iCurrentMinute == id(ha_3_minute).state && id(ha_3_enabled).state) {
            if (id(alarm_enabled).state && id(ha_3_alarmed).state || !id(ha_3_alarmed).state) {
              id(ha_3_on).turn_on();
              ESP_LOGD("check_alarms", "ha 3 on");
            }
          }
          if (iCurrentHour == id(ha_4_hour).state && iCurrentMinute == id(ha_4_minute).state && id(ha_4_enabled).state) {
            if (id(alarm_enabled).state && id(ha_4_alarmed).state || !id(ha_4_alarmed).state) {
              id(ha_4_on).turn_on();
              ESP_LOGD("check_alarms", "ha 4 on");
            }
          }
          if (id(snooze_on).state) {
            int snoozeTimestamp = id(snooze_timestamp);
            //ESP_LOGD("check_alarms", "current %i snooze %i", currentTimeForAlarmTimeStamp, snoozeTimestamp);
            if (currentTimeForAlarmTimeStamp >= snoozeTimestamp) {
              id(snooze_on).turn_off();
              ESP_LOGD("check_alarms", "snooze off");
              if (id(alarm_enabled).state && !id(alarm_on).state) {
                id(alarm_on).turn_on();
                ESP_LOGD("check_alarms", "snooze alarm on");
              }
            }
          }
          if (id(sleep_timer_on).state) {
            int sleepTimerTimestamp = id(sleep_timer_timestamp).state;
            //ESP_LOGD("check_alarms", "current %i sleeptimer %i", currentTimeForAlarmTimeStamp, sleepTimerTimestamp);
            if (currentTimeForAlarmTimeStamp >= sleepTimerTimestamp) {
              id(sleep_timer_on).turn_off();
              ESP_LOGD("check_alarms", "Sleep timer disabled");
            }
          }
  - id: media_player_watchdog
    mode: single
    then:
      - lambda: |-
          //ESP_LOGD("media_player_watchdog", "Media player state %i", id(media_player_alarm).state);
          if (!id(time_sync_done)) {
            //do nothing, time sync needs to be done
          }
          else if (id(media_player_alarm).state == 2 && !id(alarm_on).state && !id(music_on).state) { //MEDIA_PLAYER_STATE_NONE = 0 , MEDIA_PLAYER_STATE_IDLE = 1 , MEDIA_PLAYER_STATE_PLAYING = 2 , MEDIA_PLAYER_STATE_PAUSED = 3 ,  MEDIA_PLAYER_STATE_ANNOUNCING = 4
            ESP_LOGD("media_player_watchdog", "Media player is playing, alarm_on and music_on are switched off");
            id(media_player_watchdog_count) = id(media_player_watchdog_count) + 1;
            if (id(media_player_watchdog_count) > 1) {
              ESP_LOGD("media_player_watchdog", "Media player is playing, media_player_watchdog_count is %i, enabling music_on", id(media_player_watchdog_count));
              id(music_on).turn_on();
            }
          }
          else if ((id(media_player_alarm).state == 0 || id(media_player_alarm).state == 1) && (id(alarm_on).state || id(music_on).state)) {
            ESP_LOGD("media_player_watchdog", "Media player is not playing, alarm_on or music_on are switched on");
            id(media_player_watchdog_count) = id(media_player_watchdog_count) + 1;
            if (id(media_player_watchdog_count) < 3) {
              ESP_LOGD("media_player_watchdog", "Media player should be playing, trying to play the configured url for count %i", id(media_player_watchdog_count));
              id(play_url).execute();
            }
            else if (id(alarm_on).state) {
              ESP_LOGW("media_player_watchdog", "Failed to start stream, enabling announcement to force alarm sound");
              id(alarm_on_local).turn_on();
            }
            else if (id(music_on).state) {
              ESP_LOGE("media_player_watchdog", "Failed to start stream, switching off music_on");
              id(music_on).turn_off();
            }
          }
          else if (id(media_player_watchdog_count) != 0) {
            ESP_LOGD("media_player_watchdog", "Resetting media_player_watchdog_count");
            id(media_player_watchdog_count) = 0;
          }
  - id: set_alarm_last_off
    then:
      - lambda:
          id(alarm_last_off) = id(ntp).now().timestamp;
          ESP_LOGD("set_alarm_last_off", "alarm_last_off %i", id(alarm_last_off));
  - id: set_snooze_timestamp
    parameters:
      timestamp: int
    then:
      - lambda:
          id(snooze_timestamp) = timestamp;
          ESP_LOGD("set_snooze_timestamp", "alarm_last_off %i", id(snooze_timestamp));
      - if:
          condition:
            - lambda: 'return { (id(time_sync_done) == true) };'
          then:
            - component.update: snooze_time
  - id: set_volume
    parameters:
      volume: int
    then:
      - media_player.volume_set: !lambda
          float newVolume = float(volume);
          float newVolumeFloat = (newVolume/100);
          ESP_LOGD("set_volume", "newVolume %f newVolumeFloat %f", newVolume, newVolumeFloat);
          return newVolumeFloat;
  - id: play_url
    then:
      - lambda:
          const esphome::optional<std::string> url = id(media_player_alarm).make_call().get_media_url();
          if (url.has_value()) {
            ESP_LOGD("play_url", "Media has URL");
          }
          else {
            ESP_LOGD("play_url", "Media has no URL");
            auto mediaPlayerCall = id(media_player_alarm).make_call();
            auto selectState = id(alarm_stream_url).state.c_str();
            mediaPlayerCall.set_media_url(selectState);
            mediaPlayerCall.perform();
            ESP_LOGD("play_url", "Setting stream url %s", selectState);
          }
          id(media_player_stopped) = 0;
  - id: time_sync_wait #this script calls itself until time is synced. if it was in boot, with delay, this script is all what the device will be doing
    mode: queued
    then:
      - delay: 1000ms
      - lambda:
          std::time_t now;
          struct tm now_tm;
          if (id(time_sync_done) == false) {
            now = std::time(NULL);
            now_tm = *localtime(&now);
            if (now > 0 && (now_tm.tm_year + 1900) > 2019) {
              ESP_LOGD("time_sync_wait", "Time is synced");
              id(time_sync_done) = true;
            }
            else {
              ESP_LOGD("time_sync_wait", "Time not synced, waiting %i", now);
              id(time_sync_wait).execute();
            }
          }
          else {
            ESP_LOGD("time_sync_wait", "Time already synced");
          }
  - id: smooth_contrast
    mode: restart
    then:
      - while:
          condition:
            lambda: 'return fabs(id(contrast_current) - id(contrast_target)) > 0.01;'
          then:
            - lambda: |-
                float step = 0.02;
                if (id(contrast_current) < id(contrast_target))
                  id(contrast_current) = std::min(id(contrast_current) + step, id(contrast_target));
                else
                  id(contrast_current) = std::max(id(contrast_current) - step, id(contrast_target));
                alarmdisplay->set_contrast(id(contrast_current));
            - delay: 50ms